  /// \file CutProcessor.cc
/*
 *
 * CutProcessor.cc source template generated by fclass
 * Creation date : lun. mai 27 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "CutProcessor.hh"

#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

using namespace std;
using namespace EVENT;

CutProcessor aCutProcessor;

CutProcessor::CutProcessor()
	: marlin::Processor("CutProcessor") {

	_description = "CutProcessor to apply some basic cuts on sdhcal data. Cut electrons and muons, keep only pions";


	registerProcessorParameter("totalNbOfHitsCut",
				 "cut on total number of hits",
				 cut1,
				 static_cast<int> (100) );

	registerProcessorParameter("NHitOverNLayerCut",
				 "cut on NHit/nbOfTouchedLayers",
				 cut2,
				 static_cast<double> (0.2) );

	registerProcessorParameter("radiusOverCog2Cut",
				 "cut on radius/cogz",
				 cut3,
				 static_cast<double> (0.4) );

	registerProcessorParameter("showerStartingLayerCut",
				 "cut on shower starting layer",
				 cut4,
				 static_cast<int> (0) );

	registerProcessorParameter("nbOfTouchedLayersCut",
				 "cut on the number of touched layers",
				 cut5,
				 static_cast<int> (0) );

	registerProcessorParameter("fractalTimesCentralCellsCut",
				 "cut on (fractalDim * hitsInCentralCells) / (ln(NHit) * NHit)",
				 cut6,
				 static_cast<double> (0.0) );

	registerProcessorParameter("nbOfHolesCut",
				 "cut on the number of holes after the shower starting point",
				 cut7,
				 static_cast<int> (0) );

	registerProcessorParameter("NHitEdgePercentCut",
				 "cut on the percentage of hits in the edges",
				 cut8,
				 static_cast<double> (0.5) );



	registerProcessorParameter("decoderString" ,
				 "decoder string for cell ID decoder" ,
				 decoderString,
				 string("M:3,S-1:3,I:9,J:9,K-1:6"));

	registerProcessorParameter("SDHCALCollectionName" ,
				 "collection name for SDHCAL hits" ,
				 SDHCALCollectionName,
				 string("HCALBarrel"));

	vector<string> ijkVec;
	ijkVec.push_back("I");
	ijkVec.push_back("J");
	ijkVec.push_back("K-1");

	registerProcessorParameter("IJKEncoding",
				 "I J K hit encoding",
				 IJKEncoding,
				 ijkVec);
}

CutProcessor::~CutProcessor() {

}


int IJKToKey( const int i , const int j , const int k ) {

	return 100*100*k+100*j+i;
}

std::vector<int> KeyToIJK( const int &key ) {

	std::vector<int> vec;
	vec.push_back( key%100 );
	vec.push_back( key/100%100 );
	vec.push_back( key/10000 );
	return vec;
}


bool CutProcessor::SortByLayer( EVENT::CalorimeterHit *caloHit1 , EVENT::CalorimeterHit *caloHit2 ) {

	return ( caloHit1->getPosition()[2] < caloHit2->getPosition()[2] );
}


void CutProcessor::init() {

	printParameters();
}


void CutProcessor::processRunHeader( LCRunHeader* run ) {

}


void CutProcessor::processEvent( EVENT::LCEvent * evt ) {

	nbOfLayers = 48;
	nbOfCellSizeX = 96;
	nbOfCellSizeY = 96;
	nlayers = std::vector<int>( nbOfLayers , 0 );
	radius = 0.0;
	showerStartingLayer = -1;
	nbOfHitsInEdge = 0;
	nbOfHolesAfterStartingPoint = 0;
	fractalDimension = 0.0;
	nbOfHitsInCentralCells = 0;

	LCCollection *collection = 0;

	try {

		collection = evt->getCollection( SDHCALCollectionName );
	}
	catch( DataNotAvailableException &e ) {

		cout << "LCIO exception thrown : " << e.what() << endl;
		throw marlin::StopProcessingException(this);
	}

	UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

	for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

		if( collection->getTypeName() != LCIO::CALORIMETERHIT )
			throw marlin::StopProcessingException(this);

		CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );
		caloHitCollection.push_back( hit );
	}

	UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
	std::sort( caloHitCollection.begin() , caloHitCollection.end() , CutProcessor::SortByLayer );

	// first cut on NHit
	if( caloHitCollection.size() < cut1 )
		throw marlin::SkipEventException(this);

	int Nhit1 = 0;
	int Nhit2 = 0;
	int Nhit3 = 0;

	double x = 0.0;
	double y = 0.0;
	double z = 0.0;
	double weight = 0.0;
	double sumweight = 0.0;

	for( unsigned int h=0 ; h<caloHitCollection.size() ; h++ ) {

		CalorimeterHit *caloHit = caloHitCollection.at(h);

		float fThr = caloHit->getEnergy();
		int I = cellIdDecoder(caloHit)[ IJKEncoding.at(0).c_str() ];
		int J = cellIdDecoder(caloHit)[ IJKEncoding.at(1).c_str() ];
		int K = cellIdDecoder(caloHit)[ IJKEncoding.at(2).c_str() ];

		if( I < 5 || I > 95 || J < 5 || J > 95 )
			nbOfHitsInEdge ++;

		// the touched layers
		nlayers.at( K ) ++;

		// number of hits for each threshold + weight for cog computation
		if(fThr>0.0 && fThr<1.2) {
			weight = 10.0;
			Nhit1++;
		}
		else if(fThr>1.1 && fThr<2.2) {
			weight = 5.0;
			Nhit2++;
		}
		else if(fThr>2.2) {
			weight = 1.0;
			Nhit3++;
		}

		x += weight*I;
		y += weight*J;
		z += weight*K;
		sumweight += weight;
	}

	// get the number of touched layers in the event
	int nbOfTouchedLayers = 0;
	for( unsigned int l=0 ; l<nlayers.size() ; l++ )
		if( nlayers.at(l) != 0 )
			nbOfTouchedLayers++;

	NHit.push_back( caloHitCollection.size() );
	NHit.push_back( Nhit1 );
	NHit.push_back( Nhit2 );
	NHit.push_back( Nhit3 );

	// debug check
	assert( (Nhit1+Nhit2+Nhit3) != NHit.at(0) );

	cog.push_back( x/sumweight );
	cog.push_back( y/sumweight );
	cog.push_back( z/sumweight );

	fractalDimension = this->GetFractalDimension();

	// calculate the shower starting layer
	for( unsigned int h=0 ; h<caloHitCollection.size() ; h++ ) {

		CalorimeterHit *caloHit = caloHitCollection.at(h);

		float fThr = caloHit->getEnergy();
		int I = cellIdDecoder(caloHit)[ IJKEncoding.at(0).c_str() ];
		int J = cellIdDecoder(caloHit)[ IJKEncoding.at(1).c_str() ];
		int K = cellIdDecoder(caloHit)[ IJKEncoding.at(2).c_str() ];

		if( fabs( I - cog.at(0) ) > 5 || fabs( J - cog.at(1) ) > 5 )
			continue;

		int count = 1;
		std::vector<int> count2(3,0);

		for( unsigned int h2=0 ; h2<caloHitCollection.size() ; h2++ ) {

			CalorimeterHit *caloHit2 = caloHitCollection.at(h2);
			int I2 = cellIdDecoder(caloHit2)[ IJKEncoding.at(0).c_str() ];
			int J2 = cellIdDecoder(caloHit2)[ IJKEncoding.at(1).c_str() ];
			int K2 = cellIdDecoder(caloHit2)[ IJKEncoding.at(2).c_str() ];

			if( h == h2 )
				continue;

			if( fabs( I2 - cog.at(0) ) < 5 && fabs( J2 - cog.at(1) ) < 5 )
				count++;

			if( fabs( I2 - cog.at(0) ) > 5 || fabs( J2 - cog.at(1) ) > 5 )
				continue;

			if( K2 == K+1 ) count2.at(0) ++;
			if( K2 == K+2 ) count2.at(1) ++;
			if( K2 == K+3 ) count2.at(2) ++;
		}

		if( count <= 4 )
			continue;

		if( count2.at(0) >= 4 && count2.at(1) >= 4 && count2.at(2) >= 4 ) {

			showerStartingLayer = K;
			break;
		}
	}

	sumweight = 0.0;
	int count = 0;

	for( unsigned int h=0 ; h<caloHitCollection.size() ; h++ ) {

		CalorimeterHit *caloHit = caloHitCollection.at(h);

		float fThr = caloHit->getEnergy();
		int I = cellIdDecoder(caloHit)[ IJKEncoding.at(0).c_str() ];
		int J = cellIdDecoder(caloHit)[ IJKEncoding.at(1).c_str() ];
		int K = cellIdDecoder(caloHit)[ IJKEncoding.at(2).c_str() ];

		if( K >= showerStartingLayer ) {

			radius += (cog.at(0) - I)*(cog.at(0) - I) + (cog.at(1) - J)*(cog.at(1) - J);
			sumweight ++;
		}

		if( ( I - cog.at(0) ) < 3 && ( J - cog.at(1) ) < 3 )
			count ++;
	}

	nbOfHitsInCentralCells = count;

	if( sumweight != 0 )
		sqrt( radius /= sumweight );


	for( int Kiter = showerStartingLayer+1 ; Kiter < showerStartingLayer+8  ; Kiter++ ) {

		int count = 0;
		for( unsigned int h=0 ; h<caloHitCollection.size() ; h++ ) {

			CalorimeterHit *caloHit = caloHitCollection.at(h);

			float fThr = caloHit->getEnergy();
			int I = cellIdDecoder(caloHit)[ IJKEncoding.at(0).c_str() ];
			int J = cellIdDecoder(caloHit)[ IJKEncoding.at(1).c_str() ];
			int K = cellIdDecoder(caloHit)[ IJKEncoding.at(2).c_str() ];

			if( K == Kiter && ( I - cog.at(0) ) < 10 && ( J - cog.at(1) ) < 10 ) {
				count++;
				break;
			}
		}
		if( count == 0 )
			nbOfHolesAfterStartingPoint ++;
	}

	if( (double)NHit.at(0)/(double)nbOfTouchedLayers > cut2 )
		throw marlin::SkipEventException(this);

	if( radius / cog.at(2) > cut3 )
		throw marlin::SkipEventException(this);

	if( showerStartingLayer < cut4 && nbOfTouchedLayers < cut5 )
		throw marlin::SkipEventException(this);

	if( (fractalDimension * nbOfHitsInCentralCells ) / ( std::log( NHit.at(0) ) * NHit.at(0) ) < cut6 )
		throw marlin::SkipEventException(this);

	if( nbOfHolesAfterStartingPoint < cut7 )
		throw marlin::SkipEventException(this);

	if( nbOfHitsInEdge / NHit.at(0) > cut8 )
		throw marlin::SkipEventException(this);

	caloHitCollection.clear();
}


void CutProcessor::check( LCEvent *evt ) {

}

void CutProcessor::end() {

}





double CutProcessor::GetFractalDimension() {

	int vec[] = {2,3,4,6,8,12,16};
	float f3D = 0;

	for(int i=0; i<7; i++) {

		int Ncube = NbOfHitsInCube(vec[i]);
		if(Ncube >= NHit.at(0)) return 0;
		f3D += std::log(float(NHit.at(0))/Ncube)/std::log(vec[i]);
	}
	return f3D/7.0;
}




int CutProcessor::NbOfHitsInCube( int cubeSize ) {

	std::vector<int> keys;
	int ncube = 0;
	UTIL::CellIDDecoder<EVENT::CalorimeterHit> idDecoder( decoderString );

	for( unsigned int h=0 ; h<caloHitCollection.size() ; h++ ) {

		CalorimeterHit *caloHit = caloHitCollection.at(h);

		int newI = idDecoder(caloHit)[IJKEncoding.at(0).c_str()]/(cubeSize+1);
		int newJ = idDecoder(caloHit)[IJKEncoding.at(1).c_str()]/(cubeSize+1);
		int newK = idDecoder(caloHit)[IJKEncoding.at(2).c_str()]/(cubeSize+1);

		int key = IJKToKey( newI , newJ , newK );

		if( std::find( keys.begin() , keys.end() , key ) != keys.end() )
			continue;

		ncube++;
		keys.push_back( key );
	}
	return ncube;
}




