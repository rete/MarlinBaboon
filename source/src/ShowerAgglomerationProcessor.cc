  /// \file ShowerAgglomerationProcessor.cc
/*
 *
 * TrackFinderProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */

// class header
#include "ShowerAgglomerationProcessor.hh"

// baboon includes
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/Calorimetry/ConnectorClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/DensityClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolatedHitMergingAlgorithm.hh"
#include "Algorithm/EventPreparation.hh"

// marlin includes
#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

#include "CfgParser/CfgParser.hh"
#include "CfgParser/Data.hh"

#include "TEveArrow.h"
#include "TEveEventManager.h"
#include "TH1D.h"


ShowerAgglomerationProcessor aShowerAgglomerationProcessor;


using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;


ShowerAgglomerationProcessor::ShowerAgglomerationProcessor()
	: marlin::Processor("ShowerAgglomerationProcessor") {

	  _description = "ShowerAgglomerationProcessor to build showers in SDHCAL";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  registerProcessorParameter("algorithmConfigFileName" ,
				     "algorithm config file name" ,
				     algorithmConfigFileName,
				     string(""));

	  registerProcessorParameter("enableMonitoring" ,
				     "enable monitoring or not" ,
				     enableMonitoring,
				     false );

	  registerProcessorParameter("displayMode" ,
				     "Display mode" ,
				     displayMode,
				     string("threshold") );

	  registerProcessorParameter("rootOutputFile" ,
				     "The ROOT output file" ,
				     rootOutputFile,
				     string("") );

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);


}

ShowerAgglomerationProcessor::~ShowerAgglomerationProcessor() {}


void ShowerAgglomerationProcessor::init() {

	monitoring = BaboonMonitoring::GetInstance();
	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();
	analysisManager = AnalysisManager::GetInstance();

	analysisManager->SetRootFileName( rootOutputFile );
	analysisManager->Init();

	BaboonMonitoring::SetEnable( enableMonitoring );

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	if( displayMode == "thresholds" )
		sdhcal->SetHitDisplayMode( kDisplayThresholds );
	else if( displayMode == "showers" )
		sdhcal->SetHitDisplayMode( kDisplayShowers );
	else if( displayMode == "tags" )
		sdhcal->SetHitDisplayMode( kDisplayTags );
	else if( displayMode == "uniform" )
		sdhcal->SetHitDisplayMode( kDisplayUniform );
	else if( displayMode == "custom" )
		sdhcal->SetHitDisplayMode( kCustom );
	else if( displayMode == "density" )
		sdhcal->SetHitDisplayMode( kCustom );
	else
		sdhcal->SetHitDisplayMode( kDisplayThresholds );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );
//
//	// Add track finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new TrackFinderAlgorithm() ) );
//
//	// Add clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add connector clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ConnectorClusteringAlgorithm() ) );

	// Add isolated hit merging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolatedHitMergingAlgorithm() ) );

	// Add event preparation
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new EventPreparation() ) );

	algorithmManager->SetConfigFileName( algorithmConfigFileName );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}

void ShowerAgglomerationProcessor::processRunHeader( LCRunHeader* run ) {

}

void ShowerAgglomerationProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	if( caloHitCollection->empty() ) {
		this->ClearContent();
		return;
	}

	cout << "event " << evt->getEventNumber() <<  endl;

	if( algorithmManager->AlgorithmIsRegistered( "EventPreparation" ) )
		algorithmManager->GetAlgorithm( "EventPreparation" )->Process();

	ClusterCollection *clusterCollection2D = new ClusterCollection();

	// Cluster all the calo in sdhcal hits in all the layers.
	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clustAlgo->SetClusteringMode( fClustering2D );
		clustAlgo->SetCalorimeter( sdhcal );
		clustAlgo->SetClusterCollection( clusterCollection2D );
		clustAlgo->Process();

		// Register them to the clustering manager just for memory management...
		for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
		}
	}

	// Find the isolated hits in sdhcal
	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm *isolAlgo = ( IsolationTaggingAlgorithm * ) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolAlgo->SetCalorimeter( sdhcal );
		isolAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("TrackFinderAlgorithm") && !clusterCollection2D->empty() ) {

		TrackFinderAlgorithm *trackFinderAlgo = ( TrackFinderAlgorithm * ) algorithmManager->GetAlgorithm("TrackFinderAlgorithm");
		trackFinderAlgo->SetCalorimeter( sdhcal );
		trackFinderAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("ConnectorClusteringAlgorithm") ) {

		ConnectorClusteringAlgorithm *connectorClustAlgo = ( ConnectorClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ConnectorClusteringAlgorithm");
		connectorClustAlgo->SetCalorimeter( sdhcal );
		connectorClustAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("IsolatedHitMergingAlgorithm") ) {

		IsolatedHitMergingAlgorithm *isolatedMerging = (IsolatedHitMergingAlgorithm*) algorithmManager->GetAlgorithm("IsolatedHitMergingAlgorithm");
		isolatedMerging->SetCalorimeter( sdhcal );
		isolatedMerging->Process();
	}


	// Analysis part

	if( !rootOutputFile.empty() ) {

		ClusterCollection *pfo = clusteringManager->GetCluster3D();


	}

	monitoring->ViewEvent();

	this->ClearContent();
}


void ShowerAgglomerationProcessor::check( LCEvent *evt ) {

}

void ShowerAgglomerationProcessor::end() {

	analysisManager->End();
}


baboon::Return ShowerAgglomerationProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			// protecting against sdhcal data with tail catcher
			if( K >= sdhcal->GetNbOfLayers() ) {
				delete caloHit;
				continue;
			}

			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}



baboon::Return ShowerAgglomerationProcessor::ClearContent() {

	sdhcal->ClearContent();

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();

	return BABOON_SUCCESS();

}

