  /// \file ShowerAgglomerationProcessor.cc
/*
 *
 * TrackFinderProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */

// class header
#include "ShowerAgglomerationProcessor.hh"

// baboon includes
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/Calorimetry/ConnectorClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/DensityClusteringAlgorithm.hh"
#include "Algorithm/EventPreparation.hh"

// marlin includes
#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

#include "CfgParser/CfgParser.hh"
#include "CfgParser/Data.hh"

#include "TEveArrow.h"
#include "TEveEventManager.h"
#include "TH1D.h"


ShowerAgglomerationProcessor aShowerAgglomerationProcessor;


using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;


ShowerAgglomerationProcessor::ShowerAgglomerationProcessor()
	: marlin::Processor("ShowerAgglomerationProcessor") {

	  _description = "ShowerAgglomerationProcessor to build showers in SDHCAL";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  registerProcessorParameter("algorithmConfigFileName" ,
				     "algorithm config file name" ,
				     algorithmConfigFileName,
				     string(""));

	  registerProcessorParameter("enableMonitoring" ,
				     "enable monitoring or not" ,
				     enableMonitoring,
				     false );

	  registerProcessorParameter("displayMode" ,
				     "Display mode" ,
				     displayMode,
				     string("threshold") );

	  registerProcessorParameter("rootOutputFile" ,
				     "The ROOT output file" ,
				     rootOutputFile,
				     string("") );

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);


}

ShowerAgglomerationProcessor::~ShowerAgglomerationProcessor() {}


void ShowerAgglomerationProcessor::init() {

	monitoring = BaboonMonitoring::GetInstance();
	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();
	analysisManager = AnalysisManager::GetInstance();

	analysisManager->SetRootFileName( rootOutputFile );
	analysisManager->Init();

	BaboonMonitoring::SetEnable( enableMonitoring );

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	if( displayMode == "thresholds" )
		sdhcal->SetHitDisplayMode( kDisplayThresholds );
	else if( displayMode == "showers" )
		sdhcal->SetHitDisplayMode( kDisplayShowers );
	else if( displayMode == "tags" )
		sdhcal->SetHitDisplayMode( kDisplayTags );
	else if( displayMode == "uniform" )
		sdhcal->SetHitDisplayMode( kDisplayUniform );
	else if( displayMode == "custom" )
		sdhcal->SetHitDisplayMode( kCustom );
	else if( displayMode == "density" )
		sdhcal->SetHitDisplayMode( kCustom );
	else
		sdhcal->SetHitDisplayMode( kDisplayThresholds );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );
//
//	// Add track finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new TrackFinderAlgorithm() ) );
//
//	// Add clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add density clustering algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new DensityClusteringAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	// Add core finder algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ConnectorClusteringAlgorithm() ) );

	// Add event preparation
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new EventPreparation() ) );

	algorithmManager->SetConfigFileName( algorithmConfigFileName );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}

void ShowerAgglomerationProcessor::processRunHeader( LCRunHeader* run ) {

}

void ShowerAgglomerationProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	if( caloHitCollection->empty() ) {
		this->ClearContent();
		return;
	}

	cout << "event " << evt->getEventNumber() <<  endl;

	if( algorithmManager->AlgorithmIsRegistered( "EventPreparation" ) )
		algorithmManager->GetAlgorithm( "EventPreparation" )->Process();

	ClusterCollection *clusterCollection2D = new ClusterCollection();

	// Cluster all the calo in sdhcal hits in all the layers.
	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clustAlgo->SetClusteringMode( fClustering2D );
		clustAlgo->SetCalorimeter( sdhcal );
		clustAlgo->SetClusterCollection( clusterCollection2D );
		clustAlgo->Process();

		// Register them to the clustering manager just for memory management...
		for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
		}
	}

	// Find the isolated hits in sdhcal
	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm *isolAlgo = ( IsolationTaggingAlgorithm * ) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolAlgo->SetCalorimeter( sdhcal );
		isolAlgo->Process();
	}

//	// if no clusters, do not run...
//	if( clusterCollection2D->empty() ) {
//
//		this->ClearContent();
//		delete clusterCollection2D;
//		return;
//	}

	if( algorithmManager->AlgorithmIsRegistered("TrackFinderAlgorithm") && !clusterCollection2D->empty() ) {

		TrackFinderAlgorithm *trackFinderAlgo = ( TrackFinderAlgorithm * ) algorithmManager->GetAlgorithm("TrackFinderAlgorithm");
		trackFinderAlgo->SetCalorimeter( sdhcal );
		trackFinderAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("ConnectorClusteringAlgorithm") ) {

		ConnectorClusteringAlgorithm *connectorClustAlgo = ( ConnectorClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ConnectorClusteringAlgorithm");
		connectorClustAlgo->SetCalorimeter( sdhcal );
		connectorClustAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		CoreFinderAlgorithm *coreFinder = ( CoreFinderAlgorithm * ) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		coreFinder->SetCalorimeter( sdhcal );
		coreFinder->Process();
	}


	if( algorithmManager->AlgorithmIsRegistered("DensityClusteringAlgorithm") ) {

		cout << "DensityClusteringAlgorithm run !" << endl;
		DensityClusteringAlgorithm *densityClustAlgo = ( DensityClusteringAlgorithm * ) algorithmManager->GetAlgorithm("DensityClusteringAlgorithm");
		densityClustAlgo->SetCalorimeter( sdhcal );
		densityClustAlgo->Process();

		ClusterCollection *clusters3D = clusteringManager->GetCluster3D();
		IntVector clusterSizes;

		for( unsigned int cl=0 ; cl<clusters3D->size() ; cl++ )
			clusterSizes.push_back( clusters3D->at(cl)->Size() );

		analysisManager->Set( "DensityClustering" , "nbOfClusters" , (int)clusters3D->size() );
		analysisManager->Set( "DensityClustering" , "clusterSizes" , &clusterSizes );
		analysisManager->Fill( "DensityClustering" );
	}



	for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {

		CaloHit *caloHit = caloHitCollection->at( h );

		if( caloHit->GetTag() == IsolatedTag() )
			caloHit->SetColor( -1 );

		if( caloHit->GetTag() == TrackTag() )
			caloHit->SetColor( kRed );

	}

	monitoring->ViewEvent();

	this->ClearContent();
}


void ShowerAgglomerationProcessor::check( LCEvent *evt ) {

}

void ShowerAgglomerationProcessor::end() {

	analysisManager->End();
}


baboon::Return ShowerAgglomerationProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			// protecting against sdhcal data with tail catcher
			if( K >= sdhcal->GetNbOfLayers() ) {
				delete caloHit;
				continue;
			}

			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}



baboon::Return ShowerAgglomerationProcessor::ClearContent() {

	sdhcal->ClearContent();

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();

	return BABOON_SUCCESS();

}



baboon::Return ShowerAgglomerationProcessor::GetCaloHitDensity( CaloHit *caloHit , double &density ) {

	BABOON_CHECK_POINTER( caloHit );

	int total = 0;
	int sum = 0;

	IntVector ijk = caloHit->GetIJK();

	for( int i=-1 ; i<=1 ; i++ ) {
		for( int j=-1 ; j<=1 ; j++ ) {
			for( int k=-1 ; k<=1 ; k++ ) {

				total++;

				if( !sdhcal->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
					continue;

				CaloHit *h = sdhcal->GetCaloHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

				int factor = 1;
				factor *= h->GetThreshold();
				sum += factor;
			}
		}
	}
	if( total != 0 )
		density = double(sum) / total;
	else density = 0;

	return BABOON_SUCCESS();
}
/*

void ShowerAgglomerationProcessor::BuildShowersFromDistances() {

	ClusterCollection *clusterCollection2D = new ClusterCollection();
	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	// order calo hit by layer. Very useful...
	map<unsigned int,CaloHitCollection*> orderedCaloHitCollection;

	for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {

		unsigned int layer = caloHitCollection->at(h)->GetIJK().at(2);

		if( orderedCaloHitCollection.find(layer) == orderedCaloHitCollection.end() )
			orderedCaloHitCollection[ layer ] = new CaloHitCollection();
		orderedCaloHitCollection[ layer ]->push_back( caloHitCollection->at(h) );
	}

	// Find 2D clusters
	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clustAlgo->SetClusteringMode( fClustering2D );
		clustAlgo->SetCalorimeter( sdhcal );
		clustAlgo->SetClusterCollection( clusterCollection2D );
		clustAlgo->Process();

		// Register them to the clustering manager just for memory management...
		for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
		}
	}

	clusterCollection2D->clear();
	delete clusterCollection2D;

	// Find the isolated hits in sdhcal
	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm *isolAlgo = ( IsolationTaggingAlgorithm * ) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolAlgo->SetCalorimeter( sdhcal );
		isolAlgo->Process();
	}

	CaloHitCollection *currentCaloHitCollection = sdhcal->GetCaloHitCollection();
	unsigned int nbOfLayers = sdhcal->GetNbOfLayers();
	double cellSize0 = sdhcal->GetCellSize0();
	double cellSize1 = sdhcal->GetCellSize1();
	double layerThickness = sdhcal->GetLayerThickness();
	double absorberThickness = sdhcal->GetAbsorberThickness();
	int repeatX = sdhcal->GetRepeatX();
	int repeatY = sdhcal->GetRepeatY();

	double shiftXFactor = cellSize0*repeatX / 2.0;
	double shiftYFactor = cellSize1*repeatY / 2.0;
	double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

	cout << "cellSize0 : " << cellSize0 << endl;
	cout << "cellSize1 : " << cellSize1 << endl;
	cout << "layerThickness : " << layerThickness << endl;
	cout << "nbOfLayers : " << nbOfLayers << endl;
	cout << "nbOfHits : " << currentCaloHitCollection->size() << endl;

	ConnectedHitsCollection *connectedHitsCollection = new ConnectedHitsCollection();
	bool first = true;

	double maxDistance = 50.0;
	double maxDistanceX = 4*cellSize0;
	double maxDistanceY = 4*cellSize1;
	double maxDistanceZ = 2.1*layerThickness;

	map<unsigned int,CaloHitCollection*>::iterator it;

	for( it=orderedCaloHitCollection.begin() ; it!=orderedCaloHitCollection.end() ; it++ ) {

		CaloHitCollection *currentCaloHitCollection = it->second;
		unsigned int currentLayer = it->first;

		for( unsigned int h1=0 ; h1<currentCaloHitCollection->size() ; h1++ ) {

			CaloHit *caloHit1 = currentCaloHitCollection->at( h1 );
			ConnectedHits *connectedHits = new ConnectedHits();
			connectedHits->otherHits = new CaloHitCollection();
			connectedHits->theHit = caloHit1;
			IntVector ijk1 = caloHit1->GetIJK();

			unsigned int nextLayer = it->first+1;

			while( 1 ) {

				map<unsigned int,CaloHitCollection*>::iterator nextIt = orderedCaloHitCollection.find( nextLayer );

				if( nextIt == orderedCaloHitCollection.end() ) {

					if( abs(currentLayer-nextLayer) > 2 )
						break;
					else {
						nextLayer++;
					}
				}
				else {
					CaloHitCollection *nextCaloHitCollection = nextIt->second;

					for( unsigned int h2=0 ; h2<nextCaloHitCollection->size() ; h2++ ) {

						CaloHit *caloHit2 = nextCaloHitCollection->at( h2 );
						IntVector ijk2 = caloHit2->GetIJK();

						if( abs( cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0) ) > maxDistanceX
						 || abs( cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1) ) > maxDistanceY )
//						 || abs( layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2) ) > maxDistanceZ )
							continue;

						double distance = sqrt( (cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0) )*(cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0))
											   + (cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1))*(cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1))
											   + (layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2))*(layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2)) );

						connectedHits->otherHits->push_back( caloHit2 );
						connectedHits->distances.push_back( distance );
						connectedHits->distanceToCaloHitMap[ distance ] = caloHit2;
					}

					if( connectedHits->distanceToCaloHitMap.size() > 3 ) {

						connectedHits->otherHits->clear();
						map<double,CaloHit*>::iterator it;
						int counter = 0;
						for( it=connectedHits->distanceToCaloHitMap.begin()
								; it!=connectedHits->distanceToCaloHitMap.end()
								; it++ ) {
							if( counter < 3 )
								connectedHits->otherHits->push_back( it->second );
							else {
								connectedHits->distanceToCaloHitMap.erase( connectedHits->distanceToCaloHitMap.begin() + counter );
							}

						}


					}


					break;
				}

			}
		}
	}


	/************************************************/



/*
	for( unsigned int h1=0 ; h1<currentCaloHitCollection->size() ; h1++ ) {

		CaloHit *caloHit1 = currentCaloHitCollection->at( h1 );

		IntVector ijk1 = caloHit1->GetIJK();
		ConnectedHits *connectedHits = new ConnectedHits();
		connectedHits->otherHits = new CaloHitCollection();
		connectedHits->theHit = caloHit1;

		for( unsigned int h2=0 ; h2<currentCaloHitCollection->size() ; h2++ ) {

			// no double counting
			if( h1 == h2 )
				continue;

			CaloHit *caloHit2 = currentCaloHitCollection->at( h2 );

			IntVector ijk2 = caloHit2->GetIJK();

			if( ijk1.at(2) >= ijk2.at(2) )
				continue;

			double distance = sqrt( (cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0) )*(cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0))
								   + (cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1))*(cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1))
								   + (layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2))*(layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2)) );

			if( abs( cellSize0*ijk1.at(0)-cellSize0*ijk2.at(0) ) > maxDistanceX
			 || abs( cellSize1*ijk1.at(1)-cellSize1*ijk2.at(1) ) > maxDistanceY
			 || abs( layerThickness*ijk1.at(2)-layerThickness*ijk2.at(2) ) > maxDistanceZ )
				continue;

			connectedHits->otherHits->push_back( caloHit2 );
			connectedHits->distances.push_back( distance );

			if( enableMonitoring && gEve ) {
				TEveArrow *connectionArrow = new TEveArrow( cellSize0*ijk2.at(0)-cellSize0*ijk1.at(0)
														  , cellSize1*ijk2.at(1)-cellSize1*ijk1.at(1)
														  , layerThickness*ijk2.at(2)-layerThickness*ijk1.at(2)
														  , cellSize0*ijk1.at(0) - shiftXFactor
														  , cellSize1*ijk1.at(1) - shiftYFactor
														  , layerThickness*ijk1.at(2) + shiftZFactor );

				connectionArrow->SetMainColor( kOrange );
				connectionArrow->SetPickable( true );
				monitoring->AddElement( connectionArrow );

			}
		}
		connectedHitsCollection->push_back( connectedHits );
	}
	/

//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->KeepGoodConnectors( connectedHitsCollection ) );

	for( unsigned int i=0 ; i<connectedHitsCollection->size() ; i++ )
		if( connectedHitsCollection->at(i) != 0 ) {
			connectedHitsCollection->at(i)->otherHits->clear();
			delete connectedHitsCollection->at(i)->otherHits;
			delete connectedHitsCollection->at(i);
		}
	delete connectedHitsCollection;
	connectedHitsCollection = 0;
}
*/

Return ShowerAgglomerationProcessor::KeepGoodConnectors( ConnectedHitsCollection *connectedHitsCollection ) {

	BABOON_CHECK_POINTER( connectedHitsCollection );

	for( unsigned int c=0 ; c<connectedHitsCollection->size() ; c++ ) {

		ConnectedHits *connectedHits = connectedHitsCollection->at( c );

		// if no or one connection, continue
		if( connectedHits->otherHits->empty() || connectedHits->otherHits->size() == 1 )
			continue;

		CaloHitCollection *otherHits = connectedHits->otherHits;

		for( unsigned int h=0 ; h<otherHits->size() ; h++ ) {

		}

	}

	return BABOON_SUCCESS();
}

