  /// \file TrackFinderProcessor.cc
/*
 *
 * TrackFinderProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */

// class header
#include "TrackFinderProcessor.hh"

// baboon includes
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"
#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"
#include "Geometry/Matrix3D.hh"
#include "Geometry/Cylinder.hh"
#include "Reconstruction/Linear3DFit.hh"

// marlin includes
#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

// root includes
#include <TEveArrow.h>

#include <valgrind/memcheck.h>

TrackFinderProcessor aTrackFinderProcessor;

using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;


TrackFinderProcessor::TrackFinderProcessor()
	: marlin::Processor("TrackFinderProcessor") {

	  _description = "TrackFinderProcessor for track finding in SDHCAL";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  registerProcessorParameter("algorithmConfigFileName" ,
				     "algorithm config file name" ,
				     algorithmConfigFileName,
				     string(""));

	  registerProcessorParameter("rootOutputFile" ,
				     "the ROOT output file for analysis" ,
				     rootOutputFile,
				     string(""));

	  registerProcessorParameter("enableMonitoring" ,
				     "enable monitoring or not" ,
				     enableMonitoring,
				     false );

	  registerProcessorParameter("clusterSizeLimit" ,
				     "The cluster size limit for a track point" ,
				     clusterSizeLimit,
				     static_cast<int>(4) );

	  registerProcessorParameter("minimumTrackSize" ,
				     "The minimum track size" ,
				     minimumTrackSize,
				     static_cast<int>(4) );

	  registerProcessorParameter("lookupDistanceX" ,
			  	  	 "lookupDistanceX" ,
				     lookupDistanceX,
				     static_cast<int>(4) );

	  registerProcessorParameter("lookupDistanceY" ,
			  	  	 "lookupDistanceY" ,
				     lookupDistanceY,
				     static_cast<int>(4) );

	  registerProcessorParameter("lookupDistanceZ" ,
			  	  	 "lookupDistanceZ" ,
				     lookupDistanceZ,
				     static_cast<int>(2) );

	  registerProcessorParameter("maximumConnectorsAngle" ,
				     "The maximum allowed angle between two consecutive clusters" ,
				     maximumConnectorsAngle,
				     static_cast<double>(0.8) );

	  registerProcessorParameter("displayMode" ,
				     "Display mode" ,
				     displayMode,
				     string("threshold") );

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);


}

TrackFinderProcessor::~TrackFinderProcessor() {}


void TrackFinderProcessor::init() {

	monitoring = BaboonMonitoring::GetInstance();
	VALGRIND_DO_QUICK_LEAK_CHECK;
	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();
	analysisManager = AnalysisManager::GetInstance();

	analysisManager->SetRootFileName( rootOutputFile );
	analysisManager->Init();

	BaboonMonitoring::SetEnable( enableMonitoring );

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	if( displayMode == "thresholds" )
		sdhcal->SetHitDisplayMode( kDisplayThresholds );
	else if( displayMode == "showers" )
		sdhcal->SetHitDisplayMode( kDisplayShowers );
	else if( displayMode == "tags" )
		sdhcal->SetHitDisplayMode( kDisplayTags );
	else if( displayMode == "uniform" )
		sdhcal->SetHitDisplayMode( kDisplayUniform );
	else if( displayMode == "custom" )
		sdhcal->SetHitDisplayMode( kCustom );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	// Add shower agglomeration algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ShowerAgglomerationAlgorithm() ) );

	// Add the track finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new TrackFinderAlgorithm() ) );

	// Add clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	algorithmManager->SetConfigFileName( algorithmConfigFileName );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}

void TrackFinderProcessor::processRunHeader( LCRunHeader* run ) {

}

void TrackFinderProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	unsigned int nbOfLayers = sdhcal->GetNbOfLayers();
	double cellSize0 = sdhcal->GetCellSize0();
	double cellSize1 = sdhcal->GetCellSize1();
	double layerThickness = sdhcal->GetLayerThickness();
	double absorberThickness = sdhcal->GetAbsorberThickness();
	int repeatX = sdhcal->GetRepeatX();
	int repeatY = sdhcal->GetRepeatY();

	double shiftXFactor = cellSize0*repeatX / 2.0;
	double shiftYFactor = cellSize1*repeatY / 2.0;
	double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

	int nbOfHits = caloHitCollection->size();

	if( caloHitCollection->empty() ) {
		this->ClearContent();
		return;
	}

	cout << "event " << evt->getEventNumber() <<  endl;


	/*********************
	 * Beginning of algo *
	 *********************/

	ClusterCollection *clusterCollection2D = new ClusterCollection();

	// Cluster all the calo in sdhcal hits in all the layers.
	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clustAlgo->SetClusteringMode( fClustering2D );
		clustAlgo->SetCalorimeter( sdhcal );
		clustAlgo->SetClusterCollection( clusterCollection2D );
		clustAlgo->Process();

		// Register them to the clustering manager just for memory management...
		for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
		}
	}

	// Find the isolated hits in sdhcal
	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm *isolAlgo = ( IsolationTaggingAlgorithm * ) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolAlgo->SetCalorimeter( sdhcal );
		isolAlgo->Process();
	}

	// if no clusters, do not run...
	if( clusterCollection2D->empty() ) {
		this->ClearContent();
		delete clusterCollection2D;
		return;
	}

//	VALGRIND_DO_QUICK_LEAK_CHECK;
	if( algorithmManager->AlgorithmIsRegistered("TrackFinderAlgorithm") ) {

		TrackFinderAlgorithm *trackFinderAlgo = ( TrackFinderAlgorithm * ) algorithmManager->GetAlgorithm("TrackFinderAlgorithm");
		trackFinderAlgo->SetCalorimeter( sdhcal );
		trackFinderAlgo->Process();
	}
//	VALGRIND_DO_QUICK_LEAK_CHECK;

	//--------------------------------------------------------------------------------------------------------------
	// Keep all the clusters that can be contained in tracks

/*
	ClusterCollection *clustersForTracks = new ClusterCollection();
	map<unsigned int,ClusterCollection*> orderedClustersForTracks;

	for( unsigned int c=0 ; c<clusterCollection2D->size() ; c++ ) {

		Cluster *cluster = clusterCollection2D->at(c);

		// Keep or not the cluster. See the function itself
		if( !this->KeepCluster( cluster , clusterCollection2D ) )
			continue;

		CaloHitCollection *caloHitCol = cluster->GetCaloHitCollection();

		// Set the cluster hits to isolated for display. Information not used afterward...
//		for( unsigned int h=0 ; h<caloHitCol->size() ; h++ ) {
//			caloHitCol->at( h )->SetTag( IsolatedTag() );
//		}

		unsigned int clusterLayer = cluster->GetCaloHitCollection()->at(0)->GetIJK().at(2);

		if( orderedClustersForTracks[ clusterLayer ] == 0 ) {
			orderedClustersForTracks[ clusterLayer ] = new ClusterCollection();
		}

		orderedClustersForTracks[ clusterLayer ]->push_back( cluster );
		clustersForTracks->push_back( cluster );

	}

//--------------------------------------------------------------------------------------------------------------

*/
	/*
	 * Connect clusters layer per layer. Try to find a cluster to connect with
	 * in a region of :
	 *
	 *  * x = [ -lookupDistanceX ; +lookupDistanceX ]
	 *  * y = [ -lookupDistanceY ; +lookupDistanceY ]
	 *
	 *  in the next layer. If nothing is found, look for the same in the next layer.
	 *
	 *  As soon as a cluster is found in the region of interest, an "ObjectConnector"
	 *  is used to connect the two clusters. This will allow to follow a potential
	 *  track cluster after cluster, layer per layer.
	 */
	/*
	for( unsigned int l=0 ; l<sdhcal->GetNbOfLayers() ; l++ ) {

		if( orderedClustersForTracks[ l ] == 0 )
			continue;

		ClusterCollection *clustersInLayer = orderedClustersForTracks[ l ];

		for( unsigned int cl=0 ; cl<clustersInLayer->size() ; cl++ ) {

			Cluster *aClusterInLayer = clustersInLayer->at( cl );
			ThreeVector clusterPosition = aClusterInLayer->GetPosition();

			if( orderedClustersForTracks[ l+1 ] == 0 ) {

				if( orderedClustersForTracks[ l+2 ] == 0  ) {
					continue;
				}
				else {

					ClusterCollection *clustersInTwoNextLayer = orderedClustersForTracks[ l+2 ];

					for( unsigned int cl2=0 ; cl2<clustersInTwoNextLayer->size() ; cl2++ ) {

						Cluster *aClusterInTwoNextLayer = clustersInTwoNextLayer->at( cl2 );
						ThreeVector clusterInTwoNextLayerPosition = aClusterInTwoNextLayer->GetPosition();

						if( abs( clusterInTwoNextLayerPosition.x() - clusterPosition.x() ) > lookupDistanceX
						 || abs( clusterInTwoNextLayerPosition.y() - clusterPosition.y() ) > lookupDistanceY
						 || abs( clusterInTwoNextLayerPosition.z() - clusterPosition.z() ) > lookupDistanceZ )
							continue;

						if( !aClusterInLayer->IsConnectedTo( aClusterInTwoNextLayer ) )
							aClusterInLayer->ConnectWith( aClusterInTwoNextLayer );
						if( !aClusterInTwoNextLayer->IsConnectedTo( aClusterInLayer ) )
							aClusterInTwoNextLayer->ConnectWith( aClusterInLayer );

					}
				}
			}
			else {

				ClusterCollection *clustersInNextLayer = orderedClustersForTracks[ l+1 ];

				for( unsigned int cl2=0 ; cl2<clustersInNextLayer->size() ; cl2++ ) {

					Cluster *aClusterInNextLayer = clustersInNextLayer->at( cl2 );
					ThreeVector clusterInNextLayerPosition = aClusterInNextLayer->GetPosition();

					if( abs( clusterInNextLayerPosition.x() - clusterPosition.x() ) > lookupDistanceX
					 || abs( clusterInNextLayerPosition.y() - clusterPosition.y() ) > lookupDistanceY
					 || abs( clusterInNextLayerPosition.z() - clusterPosition.z() ) > lookupDistanceZ )
						continue;

					if( !aClusterInLayer->IsConnectedTo( aClusterInNextLayer ) )
						aClusterInLayer->ConnectWith( aClusterInNextLayer );
					if( !aClusterInNextLayer->IsConnectedTo( aClusterInLayer ) )
						aClusterInNextLayer->ConnectWith( aClusterInLayer );
				}
			}
		}
	}


	TH1I *angleHisto = new TH1I("angleHisto","Angles",314,0,3.14);

	// Just for a plot ...
	for( unsigned int c=0 ; c<clustersForTracks->size() ; c++ ) {

		unsigned int nbOfBackwardConnections = this->HowManyBackwardConnections( clustersForTracks->at(c) );
		unsigned int nbOfForwardConnections = this->HowManyForwardConnections( clustersForTracks->at(c) );

		if( nbOfBackwardConnections == 0
		 && nbOfForwardConnections == 0 )
			continue;

		bool isSeedCluster = false;

		if( nbOfBackwardConnections == 0 )
			isSeedCluster = true;

		ThreeVector clusterPosition = clustersForTracks->at(c)->GetPosition();

		ObjectConnectorCollection *connectors = clustersForTracks->at(c)->GetObjectConnectorCollection();

		for( unsigned int co=0 ; co<connectors->size() ; co++ ) {

			Cluster *nextCluster = (Cluster *) connectors->at( co )->GetSecond();
			ThreeVector nextClusterPosition = nextCluster->GetPosition();
			angleHisto->Fill( clusterPosition.angle( nextClusterPosition ) );
		}
	}


	// Just for memory management ...
	clusterAgglomerats = new ClusterAgglomeratVec();
*/
	/*
	 * Run the algorithm with the connected clusters.
	 *
	 * Start from a given cluster and try to find a minimum set
	 * of clusters to build a track. The minimum size of this
	 * track is given by the parameter "minimumTrackSize".
	 *
	 * The main method is a recursive method that take a cluster
	 * and check if there are connector aligned with a maximum
	 * angle of "maximumConnectorsAngle". If something is found,
	 * then the algorithm is run again on the next connector that
	 * satisfies the angle conditions. If no connection is found
	 * and if the set has a minimum size of "minimumTrackSize"
	 * then add the set of aligned clusters to a collection of
	 * potential tracks.
	 *
	 */

	/*
	for( unsigned int c=0 ; c<clustersForTracks->size() ; c++ ) {

		Cluster *cluster = clustersForTracks->at(c);

		unsigned int nbOfBackwardConnections = this->HowManyBackwardConnections( clustersForTracks->at(c) );
		unsigned int nbOfForwardConnections = this->HowManyForwardConnections( clustersForTracks->at(c) );

		// If no connection is the next planes,
		// the cluster is not a good one to start with.
		if( nbOfForwardConnections == 0 )
			continue;

		// Use a struct with the needed information to follow the connectors
		ClusterAgglomerat *clusterAgglomerat = new ClusterAgglomerat();
		clusterAgglomerat->cluster = cluster;
		clusterAgglomerat->forwardCluster = 0;
		clusterAgglomerat->forwardConnector = 0;
		clusterAgglomerat->shouldFollowNextConnector = false;
		clusterAgglomerat->clusterCollection = new ClusterCollection();
		clusterAgglomerat->clusterCollection->push_back( cluster );
		clusterAgglomerat->isFirstCluster = true;

		clusterAgglomerats->push_back( clusterAgglomerat );

		// The recursive function ...
		this->FindPotentialTrack( clusterAgglomerat );

	}

	// The tracks are sorted by decreasing sizes.
	this->SortClusterCollectionsBySize( potentialTracks );

	std::vector<ClusterCollection *> finalTracks;
	ClusterCollection treatedClusters;

	cout << "potentialTracks.size() : " << potentialTracks.size() << endl;

	for( unsigned int pt=0 ; pt<potentialTracks.size() ; pt++ ) {

		ClusterCollection *potentialTrack = potentialTracks.at( pt );

		if( pt == 0 ) {
			finalTracks.push_back( potentialTrack );
			treatedClusters = ClusterCollection( *potentialTrack );
		}
		else {

			for( unsigned int cl=0 ; cl<potentialTrack->size() ; cl++ ) {

				Cluster *cluster = potentialTrack->at( cl );

				if( std::find( treatedClusters.begin() , treatedClusters.end() , cluster ) != treatedClusters.end() ) {

					potentialTrack->erase( potentialTrack->begin()+cl );
					cl --;
				}
			}

			// Keep the track if after removing the redundant clusters the track is long enough
			if( potentialTrack->size() >= minimumTrackSize ) {

				// First, find if there is a hole in the track, that is to
				// say a track with at least two empty layers. In this case,
				// delete this track ...
				this->SortClustersByLayer( potentialTrack );
				bool shouldKeep = true;

				for( unsigned int cl=0 ; cl<potentialTrack->size() ; cl++ ) {

					if( cl != potentialTrack->size() - 1 ) {

						Cluster *cluster = potentialTrack->at(cl);
						Cluster *nextCluster = potentialTrack->at(cl+1);

						if( abs( cluster->GetPosition().z() - nextCluster->GetPosition().z() ) > 2 ) {
							shouldKeep = false;
							break;
						}
					}
				}

				// ... else keep this track ! This is a good one !
				if( shouldKeep ) {
					finalTracks.push_back( potentialTrack );

					for( unsigned int cl=0 ; cl<potentialTrack->size() ; cl++ ) {
						treatedClusters.push_back( potentialTrack->at(cl) );
					}
				} // shouldKeep
			} // if minimumTrackSize
		} // else
	} // for


	// Build "Track" objects
	for( unsigned int pt=0 ; pt<finalTracks.size() ; pt++ ) {

		ClusterCollection *trackClusters = finalTracks.at( pt );
		Track *track = new Track();

		for( unsigned int cl=0 ; cl<trackClusters->size() ; cl++ ) {

			CaloHitCollection *clusterHits = trackClusters->at( cl )->GetCaloHitCollection();

			for( unsigned int h=0 ; h<clusterHits->size() ; h++ ) {

				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , track->AddCaloHit( clusterHits->at(h) ) );
				clusterHits->at(h)->SetTag( TrackTag() );
			}
		}

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , trackManager->AddTrack( track ) );

		// Draw the connectors between clusters in a given track
		this->DrawTrackConnectors( finalTracks.at( pt ) , pt+1 );
	}

	// Build the showers in sdhcal
	if( algorithmManager->AlgorithmIsRegistered("ShowerAgglomerationAlgorithm") ) {

		ShowerAgglomerationAlgorithm *showerAlgo = ( ShowerAgglomerationAlgorithm * ) algorithmManager->GetAlgorithm("ShowerAgglomerationAlgorithm");
		showerAlgo->SetCalorimeter( sdhcal );
		showerAlgo->Process();
	}
*/

	/***************
	 * End of algo *
	 ***************/




//	// calo hit color, in case of custom setting ...
	for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {
//
		CaloHit *caloHit = caloHitCollection->at( h );
//		IntVector ijk = caloHit->GetIJK();
//		int count = 0;
//
//		for( int i=-1 ; i<=1 ; i++ ) {
//			for( int j=-1 ; j<=1 ; j++ ) {
//				for( int k=-1 ; k<=1 ; k++ ) {
//
//					if( !sdhcal->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
//						continue;
//					count++;
//				}
//			}
//		}
//
//		if( caloHit->GetTag() != TrackTag() && caloHit->GetTag() != IsolatedTag() ) {
//			int color = BaboonMonitoring::GetColorBetweenMinAndMax( exp(0.0) , exp(3.0) , exp(count/27.0) );
//			caloHit->SetColor( color );
//			continue;
//		}
		if( caloHit->GetTag() == TrackTag() ) {
			caloHit->SetColor( kBlack );
			continue;
		}

		if( caloHit->GetThreshold() == fCaloHitThr1 )
			caloHit->SetColor( kGreen );
		if( caloHit->GetThreshold() == fCaloHitThr2 )
			caloHit->SetColor( kBlue );
		if( caloHit->GetThreshold() == fCaloHitThr3 )
			caloHit->SetColor( kRed );

//		if( caloHit->GetTag() == IsolatedTag() ) {
//			caloHit->SetColor( -1 );
//			continue;
//		}
	}


	TrackCollection *trackCollection = trackManager->GetTrackCollection();

	// Analysis variable registration
	int nbOfTracks = trackCollection->size();
	IntVector nbOfHitsForEachTrack;
	int nbOfTrackHits = 0;
	DoubleVector trackMultiplicities;
	DoubleVector trackLengthsMM;
	IntVector trackLengthsLayer;

	for( unsigned int tr=0 ; tr<trackCollection->size() ; tr++ ) {

		Track *track = trackCollection->at( tr );
		track->SortHits();
		nbOfHitsForEachTrack.push_back( track->Size() );
		IntVector firedPlanes;
		CaloHitCollection *trackHits = track->GetCaloHitCollection();

		double trackLengthMM = 0;
		int trackLengthLayer = trackHits->at( trackHits->size() - 1 )->GetIJK().at(2) - trackHits->at(0)->GetIJK().at(2);

		for( unsigned int h=0 ; h<track->Size() ; h++ ) {

			CaloHit *caloHit = trackHits->at( h );

			if( h != track->Size() - 1 ) {

				Cluster *cluster = clusteringManager->GetClusterContainingCaloHit( fCluster2D , caloHit );
				CaloHit *nextCaloHit = trackHits->at( h+1 );
				Cluster *nextCluster = clusteringManager->GetClusterContainingCaloHit( fCluster2D , nextCaloHit );

				if( cluster != nextCluster ) {

					ThreeVector clusterPosition = cluster->GetPosition();
					ThreeVector nextClusterPosition = nextCluster->GetPosition();
					ThreeVector distanceVector = nextClusterPosition - clusterPosition;
					distanceVector.setX( distanceVector.x()*cellSize0 );
					distanceVector.setY( distanceVector.y()*cellSize1 );
					distanceVector.setZ( distanceVector.z()*layerThickness );
					trackLengthMM += distanceVector.mag();
				}
			}

			if( std::find( firedPlanes.begin() , firedPlanes.end() , caloHit->GetIJK().at(2) ) == firedPlanes.end() )
				firedPlanes.push_back( caloHit->GetIJK().at(2) );

		}
		trackLengthsMM.push_back( trackLengthMM );
		trackLengthsLayer.push_back( trackLengthLayer );
		nbOfTrackHits += track->Size();
		trackMultiplicities.push_back( (double)track->Size() / (double)firedPlanes.size() );
	}

//	analysisManager->Set( "TrackAnalysis" , "nbOfTracks" , nbOfTracks );
//	analysisManager->Set( "TrackAnalysis" , "nbOfTrackHits" , nbOfTrackHits );
//	analysisManager->Set( "TrackAnalysis" , "nbOfHitsForEachTrack" , &nbOfHitsForEachTrack );
//	analysisManager->Set( "TrackAnalysis" , "trackMultiplicities" , &trackMultiplicities );
//	analysisManager->Set( "TrackAnalysis" , "trackLengthsMM" , &trackLengthsMM );
//	analysisManager->Set( "TrackAnalysis" , "trackLengthsLayer" , &trackLengthsLayer );
//	analysisManager->Fill( "TrackAnalysis" );



	// View event if the monitoring is available
	monitoring->ViewEvent();


/*
	// deletion area
	delete angleHisto;

	for( unsigned int cl=0 ; cl<clusterAgglomerats->size() ; cl++ ) {
		if( clusterAgglomerats->at( cl ) !=0 ) {
			delete clusterAgglomerats->at( cl )->clusterCollection;
			delete clusterAgglomerats->at( cl );
		}
	}

	clusterAgglomerats->clear();
	delete clusterAgglomerats;
	clusterAgglomerats = 0;


	// each cluster is deleted by the clusteringManager
	clusterCollection2D->clear();
	delete clusterCollection2D;
	clustersForTracks->clear();
	delete clustersForTracks;

	potentialTracks.clear();
	finalTracks.clear();
	treatedClusters.clear();

	*/

	this->ClearContent();
}





void TrackFinderProcessor::check( LCEvent *evt ) {

}

void TrackFinderProcessor::end() {

	analysisManager->End();
	VALGRIND_DO_ADDED_LEAK_CHECK;
}


baboon::Return TrackFinderProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			// protecting against sdhcal data with tail catcher
			if( K >= sdhcal->GetNbOfLayers() ) {
				delete caloHit;
				continue;
			}
			// protecting against double hit counting
			if( !sdhcal->IsPadFired( I , J , K ) ) {
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
			}
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}



baboon::Return TrackFinderProcessor::ClearContent() {

	sdhcal->ClearContent();

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();

	return BABOON_SUCCESS();

}



void TrackFinderProcessor::DrawEveArrow( Calorimeter *calorimeter ,
										  double I1 , double J1 , double K1 ,
										  double I2 , double J2 , double K2 ,
										  int color ) {

	unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
	double cellSize0 = calorimeter->GetCellSize0();
	double cellSize1 = calorimeter->GetCellSize1();
	double layerThickness = calorimeter->GetLayerThickness();
	double absorberThickness = calorimeter->GetAbsorberThickness();
	int repeatX = calorimeter->GetRepeatX();
	int repeatY = calorimeter->GetRepeatY();

	double shiftXFactor = cellSize0*repeatX / 2.0;
	double shiftYFactor = cellSize1*repeatY / 2.0;
	double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

	if( enableMonitoring && gEve ) {
		TEveArrow *connectionArrow = new TEveArrow( cellSize0*I2-cellSize0*I1
												  , cellSize1*J2-cellSize1*J1
												  , layerThickness*K2-layerThickness*K1
												  , cellSize0*I1 - shiftXFactor
												  , cellSize1*J1 - shiftYFactor
												  , layerThickness*K1 + shiftZFactor );

		connectionArrow->SetMainColor( color );
		connectionArrow->SetPickable( true );
		connectionArrow->SetTubeR( 0.05 );
		connectionArrow->SetConeR( 0.008 );
		connectionArrow->SetConeL( 0.008 );
		monitoring->AddElement( connectionArrow );
	}

}



unsigned int TrackFinderProcessor::HowManyBackwardConnections( Cluster *cluster ) {

	unsigned int nbOfBackwardConnections = 0;
	ObjectConnectorCollection *connections = cluster->GetObjectConnectorCollection();

	for( unsigned int c=0 ; c<connections->size() ; c++ ) {

		Cluster *connectedCluster = (Cluster *) connections->at(c)->GetSecond();

		if( cluster->GetPosition().z() > connectedCluster->GetPosition().z() )
			nbOfBackwardConnections++;

	}

	return nbOfBackwardConnections;
}



unsigned int TrackFinderProcessor::HowManyForwardConnections( Cluster *cluster ) {

	unsigned int nbOfForwardConnections = 0;
	ObjectConnectorCollection *connections = cluster->GetObjectConnectorCollection();

	for( unsigned int c=0 ; c<connections->size() ; c++ ) {

		Cluster *connectedCluster = (Cluster *) connections->at(c)->GetSecond();

		if( cluster->GetPosition().z() < connectedCluster->GetPosition().z() )
			nbOfForwardConnections++;

	}

	return nbOfForwardConnections;
}


/*
void TrackFinderProcessor::FindPotentialTrack( ClusterAgglomerat *clusterAgglo ) {

	double cellSize0 = sdhcal->GetCellSize0();
	double cellSize1 = sdhcal->GetCellSize1();
	double layerThickness = sdhcal->GetLayerThickness();

	if( clusterAgglo->isFirstCluster ) {

		Cluster *cluster = clusterAgglo->seedCluster;
		ThreeVector clusterPosition = cluster->GetPosition();
		clusterPosition.setX( clusterPosition.x()*cellSize0 );
		clusterPosition.setY( clusterPosition.y()*cellSize1 );
		clusterPosition.setZ( clusterPosition.z()*layerThickness );

		ObjectConnectorCollection *objConnectors = cluster->GetObjectConnectorCollection();

		for( unsigned int c=0 ; c<objConnectors->size() ; c++ ) {

			ObjectConnector *connector = objConnectors->at( c );
			Cluster *nextCluster = (Cluster *) connector->GetSecond();
			ThreeVector nextClusterPosition = nextCluster->GetPosition();
			nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
			nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
			nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

			if( cluster->GetPosition().z() >= nextCluster->GetPosition().z() )
				continue;

			ObjectConnectorCollection *nextObjConnectors = nextCluster->GetObjectConnectorCollection();

			bool connectorFound = false;

			for( unsigned int c2=0 ; c2<nextObjConnectors->size() ; c2++ ) {

				ObjectConnector *nextConnector = nextObjConnectors->at( c2 );
				Cluster *nextNextCluster = (Cluster *) nextConnector->GetSecond();
				ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();
				nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
				nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
				nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

				if( nextCluster->GetPosition().z() >= nextNextCluster->GetPosition().z() )
					continue;

				ThreeVector x1 = nextClusterPosition - clusterPosition;
				ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
				double angle = x1.angle( x2 );

				if( angle > maximumConnectorsAngle ) {
					continue;
				}

				unsigned int oldSize = clusterAgglo->clusterCollection->size();
				clusterAgglo->shouldFollowNextConnector = true;
				clusterAgglo->isFirstCluster = false;
				clusterAgglo->cluster = nextCluster;
				clusterAgglo->forwardCluster = nextNextCluster;
				clusterAgglo->forwardConnector = nextConnector;
				clusterAgglo->clusterCollection->push_back( nextCluster );
				connectorFound = true;



				this->FindPotentialTrack( clusterAgglo );

				if( clusterAgglo->clusterCollection->size() != oldSize ) {
					clusterAgglo->clusterCollection->erase( clusterAgglo->clusterCollection->begin() + oldSize , clusterAgglo->clusterCollection->end() );
				}

				clusterAgglo->isFirstCluster = true;
				clusterAgglo->cluster = cluster;
				clusterAgglo->forwardCluster = 0;
				clusterAgglo->forwardConnector = 0;
			}

			if( !connectorFound  && clusterAgglo->clusterCollection->size() >= minimumTrackSize ) {

				ClusterCollection *potentialTrack = new ClusterCollection( *clusterAgglo->clusterCollection );
//				vector<ThreeVector> positions;
//				for( unsigned int cl=0 ; cl<clusterAgglo->clusterCollection->size() ; cl++ )
//					positions.push_back( clusterAgglo->clusterCollection->at( cl )->GetPosition() );
//				vector<ThreeVector> weights( clusterAgglo->clusterCollection->size() , ThreeVector(1,1,1) );
//				Linear3DFit fitter( positions , weights );
//				fitter.Fit();
//				clusterAgglo->chi2Track = fitter.GetChi2();
//				cout << "clusterAgglo->chi2Track : " << clusterAgglo->chi2Track << endl;
				potentialTracks.push_back( potentialTrack );
			}
		}



	} // isFirstCluster
	else {

		Cluster *cluster = clusterAgglo->cluster;
		ThreeVector clusterPosition = cluster->GetPosition();
		clusterPosition.setX( clusterPosition.x()*cellSize0 );
		clusterPosition.setY( clusterPosition.y()*cellSize1 );
		clusterPosition.setZ( clusterPosition.z()*layerThickness );


		if( clusterAgglo->shouldFollowNextConnector ) {

			ObjectConnector *forwardConnector = clusterAgglo->forwardConnector;
			Cluster *nextCluster = clusterAgglo->forwardCluster;
			ThreeVector nextClusterPosition = nextCluster->GetPosition();
			nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
			nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
			nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

			ObjectConnectorCollection *nextObjConnectors = nextCluster->GetObjectConnectorCollection();

			bool connectorFound = false;

			for( unsigned int c2=0 ; c2<nextObjConnectors->size() ; c2++ ) {

				ObjectConnector *nextConnector = nextObjConnectors->at( c2 );
				Cluster *nextNextCluster = (Cluster *) nextConnector->GetSecond();
				ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();
				nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
				nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
				nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

				if( nextCluster->GetPosition().z() >= nextNextCluster->GetPosition().z() )
					continue;

				ThreeVector x1 = nextClusterPosition - clusterPosition;
				ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
				double angle = x1.angle( x2 );

				if( angle > maximumConnectorsAngle ) {
					continue;
				}

				// then the connector is a good one, update the data ...
				unsigned int oldSize = clusterAgglo->clusterCollection->size();
				clusterAgglo->shouldFollowNextConnector = true;
				clusterAgglo->isFirstCluster = false;
				clusterAgglo->cluster = nextCluster;
				clusterAgglo->forwardCluster = nextNextCluster;
				clusterAgglo->forwardConnector = nextConnector;
				clusterAgglo->clusterCollection->push_back( nextCluster );
				connectorFound = true;

				// ... and run again the method
				this->FindPotentialTrack( clusterAgglo );


				if( clusterAgglo->clusterCollection->size() != oldSize ) {
					clusterAgglo->clusterCollection->erase( clusterAgglo->clusterCollection->begin() + oldSize , clusterAgglo->clusterCollection->end() );
				}

				clusterAgglo->shouldFollowNextConnector = true;
				clusterAgglo->isFirstCluster = false;
				clusterAgglo->cluster = cluster;
				clusterAgglo->forwardCluster = nextCluster;
				clusterAgglo->forwardConnector = forwardConnector;
			}

			if( !connectorFound ) {

				clusterAgglo->clusterCollection->push_back( nextCluster );

				if( clusterAgglo->clusterCollection->size() >= minimumTrackSize) {

					ClusterCollection *potentialTrack = new ClusterCollection( *clusterAgglo->clusterCollection );
//					vector<ThreeVector> positions;
//					for( unsigned int cl=0 ; cl<clusterAgglo->clusterCollection->size() ; cl++ )
//						positions.push_back( clusterAgglo->clusterCollection->at( cl )->GetPosition() );
//					vector<ThreeVector> weights( clusterAgglo->clusterCollection->size() , ThreeVector(1,1,1)  );
//					Linear3DFit fitter( positions , weights );
//					fitter.Fit();
//					clusterAgglo->chi2Track = fitter.GetChi2();
//					cout << "clusterAgglo->chi2Track : " << clusterAgglo->chi2Track << endl;
					potentialTracks.push_back( potentialTrack );
				}
			}

		}

	}

}
//*/

//*
void TrackFinderProcessor::FindPotentialTrack( ClusterAgglomerat *clusterAgglo ) {

	double cellSize0 = sdhcal->GetCellSize0();
	double cellSize1 = sdhcal->GetCellSize1();
	double layerThickness = sdhcal->GetLayerThickness();

	if( clusterAgglo->isFirstCluster ) {

		Cluster *cluster = clusterAgglo->cluster;
		ThreeVector clusterPosition = cluster->GetPosition();
		clusterPosition.setX( clusterPosition.x()*cellSize0 );
		clusterPosition.setY( clusterPosition.y()*cellSize1 );
		clusterPosition.setZ( clusterPosition.z()*layerThickness );

		ObjectConnectorCollection *objConnectors = cluster->GetObjectConnectorCollection();

		for( unsigned int c=0 ; c<objConnectors->size() ; c++ ) {

			ObjectConnector *connector = objConnectors->at( c );
			Cluster *nextCluster = (Cluster *) connector->GetSecond();
			ThreeVector nextClusterPosition = nextCluster->GetPosition();
			nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
			nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
			nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

			if( cluster->GetPosition().z() >= nextCluster->GetPosition().z() )
				continue;

			ObjectConnectorCollection *nextObjConnectors = nextCluster->GetObjectConnectorCollection();

			bool connectorFound = false;
			double bestAngle = 10.0;
			ObjectConnector *bestNextConnector = 0;
			Cluster *bestNextCluster = 0;

			for( unsigned int c2=0 ; c2<nextObjConnectors->size() ; c2++ ) {

				ObjectConnector *nextConnector = nextObjConnectors->at( c2 );
				Cluster *nextNextCluster = (Cluster *) nextConnector->GetSecond();
				ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();

				nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
				nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
				nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

				if( nextCluster->GetPosition().z() >= nextNextCluster->GetPosition().z() )
					continue;

				ThreeVector x1 = nextClusterPosition - clusterPosition;
				ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
				double angle = x1.angle( x2 );

				if( angle < bestAngle ) {

					bestAngle = angle;
					bestNextConnector = nextConnector;
					bestNextCluster = nextNextCluster;
				}
			}

			if( bestAngle > maximumConnectorsAngle ) {

				bestAngle = 10.0;
				bestNextConnector = 0;
				bestNextCluster = 0;
				continue;
			}

			unsigned int oldSize = clusterAgglo->clusterCollection->size();
			clusterAgglo->shouldFollowNextConnector = true;
			clusterAgglo->isFirstCluster = false;
			clusterAgglo->cluster = nextCluster;
			clusterAgglo->forwardCluster = bestNextCluster;
			clusterAgglo->forwardConnector = bestNextConnector;
			clusterAgglo->clusterCollection->push_back( nextCluster );
			connectorFound = true;

			this->FindPotentialTrack( clusterAgglo );

			clusterAgglo->isFirstCluster = true;
			clusterAgglo->cluster = cluster;
			clusterAgglo->forwardCluster = 0;
			clusterAgglo->forwardConnector = 0;
			clusterAgglo->clusterCollection->clear();
		}



	} // isFirstCluster
	else {

		Cluster *cluster = clusterAgglo->cluster;
		ThreeVector clusterPosition = cluster->GetPosition();
		clusterPosition.setX( clusterPosition.x()*cellSize0 );
		clusterPosition.setY( clusterPosition.y()*cellSize1 );
		clusterPosition.setZ( clusterPosition.z()*layerThickness );

		ObjectConnector *forwardConnector = clusterAgglo->forwardConnector;
		Cluster *nextCluster = clusterAgglo->forwardCluster;
		ThreeVector nextClusterPosition = nextCluster->GetPosition();
		nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
		nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
		nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

		ObjectConnectorCollection *nextObjConnectors = nextCluster->GetObjectConnectorCollection();

		bool connectorFound = false;
		double bestAngle = 10.0;
		ObjectConnector *bestNextConnector = 0;
		Cluster *bestNextCluster = 0;

		for( unsigned int c2=0 ; c2<nextObjConnectors->size() ; c2++ ) {

			ObjectConnector *nextConnector = nextObjConnectors->at( c2 );
			Cluster *nextNextCluster = (Cluster *) nextConnector->GetSecond();
			ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();

			nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
			nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
			nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

			if( nextCluster->GetPosition().z() >= nextNextCluster->GetPosition().z() )
				continue;

			ThreeVector x1 = nextClusterPosition - clusterPosition;
			ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
			double angle = x1.angle( x2 );

			if( angle < bestAngle ) {

				bestAngle = angle;
				bestNextConnector = nextConnector;
				bestNextCluster = nextNextCluster;
			}
		}

		if( bestAngle > maximumConnectorsAngle ) {

			if( clusterAgglo->clusterCollection->size() >= minimumTrackSize-1 ) {

				clusterAgglo->clusterCollection->push_back( nextCluster );
				ClusterCollection *potentialTrack = new ClusterCollection( *clusterAgglo->clusterCollection );
				potentialTracks.push_back( potentialTrack );
			}
			return;
		}

		unsigned int oldSize = clusterAgglo->clusterCollection->size();

		clusterAgglo->shouldFollowNextConnector = true;
		clusterAgglo->isFirstCluster = false;
		clusterAgglo->cluster = nextCluster;
		clusterAgglo->forwardCluster = bestNextCluster;
		clusterAgglo->forwardConnector = bestNextConnector;
		clusterAgglo->clusterCollection->push_back( nextCluster );

		this->FindPotentialTrack( clusterAgglo );


		if( clusterAgglo->clusterCollection->size() != oldSize ) {
			clusterAgglo->clusterCollection->erase( clusterAgglo->clusterCollection->begin() + oldSize , clusterAgglo->clusterCollection->end() );
		}

		clusterAgglo->shouldFollowNextConnector = true;
		clusterAgglo->isFirstCluster = false;
		clusterAgglo->cluster = cluster;
		clusterAgglo->forwardCluster = nextCluster;
		clusterAgglo->forwardConnector = forwardConnector;
	}
}
//*/

void TrackFinderProcessor::SortClusterCollectionsBySize( std::vector<ClusterCollection *> &vec ) {

	int i = 0;
	int j = 0;
	ClusterCollection *clCol = 0;

	for( j=1 ; j<vec.size() ; j++ ) {

		i = j-1;
		while( vec.at(j)->size() > vec.at(i)->size() ) {
			clCol = vec.at(i);
			vec.at(i) = vec.at(j);
			vec.at(j) = clCol;
			i=i-1;
			j=j-1;
			if( i<0 ) break;
		}
	}
}

void TrackFinderProcessor::SortClustersByLayer( ClusterCollection *clusterCol ) {

	int i = 0;
	int j = 0;
	Cluster *cl = 0;

	for( j=1 ; j<clusterCol->size() ; j++ ) {

		i = j-1;
		while( clusterCol->at(j)->GetPosition().z() > clusterCol->at(i)->GetPosition().z() ) {
			cl = clusterCol->at(i);
			clusterCol->at(i) = clusterCol->at(j);
			clusterCol->at(j) = cl;
			i=i-1;
			j=j-1;
			if( i<0 ) break;
		}
	}
}


void TrackFinderProcessor::DrawTrackConnectors( ClusterCollection *trackClusters , int color ) {

	Cluster *currentCluster = 0;
	Cluster *nextCluster = 0;

	for( unsigned int cl=0 ; cl<trackClusters->size() ; cl++ ) {

		// The last cluster is not connected, since it is the last one ...
		if( cl == trackClusters->size() - 1 )
			break;

		currentCluster = trackClusters->at( cl );
		nextCluster = trackClusters->at( cl + 1 );

		ThreeVector currentClusterPosition = currentCluster->GetPosition();
		ThreeVector nextClusterPosition = nextCluster->GetPosition();

		this->DrawEveArrow( sdhcal ,
				currentClusterPosition.x() , currentClusterPosition.y() , currentClusterPosition.z() ,
				nextClusterPosition.x() , nextClusterPosition.y() , nextClusterPosition.z() ,
				color );

	}

}


bool TrackFinderProcessor::KeepCluster( Cluster *cluster , ClusterCollection *clusterCollection ) {

	if( cluster == 0 )
		return false;

	if( cluster->Size() > clusterSizeLimit )
		return false;

	if( clusterCollection == 0 )
		return true;

	ThreeVector clusterPosition = cluster->GetPosition();
	int neighborClusters = 0;

	for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

		Cluster *otherCluster = clusterCollection->at( cl );

		if( otherCluster == cluster )
			continue;

		ThreeVector otherClusterPosition = otherCluster->GetPosition();

		// look in the same layer
		if( otherClusterPosition.z() != clusterPosition.z() )
			continue;

		if( abs( otherClusterPosition.x() - clusterPosition.x() ) < 5
		 && abs( otherClusterPosition.y() - clusterPosition.y() ) < 5 ) {

			neighborClusters++;

			if( otherCluster->Size() > clusterSizeLimit )
				return false;
		}

		if( neighborClusters == 2 )
			return false;

	}

	return true;
}


