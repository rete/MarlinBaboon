  /// \file EnergyMinimizerProcessor.cc
/*
 *
 * EnergyMinimizerProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author rete
 *
 */

// class header
#include "EnergyMinimizerProcessor.hh"

// baboon includes
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"
#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"
#include "Algorithm/EventPreparation.hh"
#include "Reconstruction/Linear3DFit.hh"
#include "Reconstruction/EnergyCalculator/SimpleEnergyCalculator.hh"


// marlin includes
#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

// root includes
//#include <TEveArrow.h>

using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;

EnergyMinimizer::EnergyMinimizer() {

	minimizerType = "SIMPLEX";
	fitter = new TFitter();

	availableMinimizerTypes.push_back( "SIMPLEX" );
	availableMinimizerTypes.push_back( "MINUIT" );
	numberOfIteration = 3;
}


EnergyMinimizer::~EnergyMinimizer() {

	delete fitter;
}



void EnergyMinimizer::SetMinimizerType( const std::string &type ) {

	minimizerType = type;
}


void EnergyMinimizer::AddParameter( const EnergyMinimizer::FitterParameter &param ) {

	bool found = false;
	for( unsigned int i=0 ; i<parameterList.size() ; i++ ) {
		if( parameterList.at(i).name == param.name ) {
			found = true;
			break;
		}
	}

	if( found )
		throw baboon::Exception( "EnergyMinimizer::AddParameter() : param name was already present" );

	// C++ 11 not available

//		auto it = std::find_if( parameterList.begin() , parameterList.end()
//				, [&]( FitterParameter &p ) -> bool { return (param.name == p.name); } );
//		if( it != parameterList.end() )
//			throw Exception( "EnergyMinimizer::AddParameter() : param name was already present" );

	parameterList.push_back( param );
}

void EnergyMinimizer::SetPrintOutLevel( double level ) {

	fitter->ExecuteCommand("SET PRINTOUT", &level , 1 );
}



void EnergyMinimizer::SetFunction( void (*func) (int& nDim , double* gout , double& result , double par[] , int flg) ) {

	if( func == nullptr )
		throw baboon::Exception( "EnergyMinimizer::SetFunction : function is a nullptr" );

	function = func;
}


void EnergyMinimizer::SetNumberOfIteration( int nbOfIt ) {

	if( nbOfIt > 0 )
		numberOfIteration = nbOfIt;
}


const std::vector<EnergyMinimizer::FitterParameter> &EnergyMinimizer::GetInputParameters() {

	return parameterList;
}


const std::vector<EnergyMinimizer::FitterParameter> &EnergyMinimizer::GetOutputParameters() {

	return outputParameterList;
}

void EnergyMinimizer::Minimize() {

	if( !Check() )
		throw baboon::Exception( "EnergyMinimizer::Minimize() : Couldn't minimize , parameter error" );

	fitter->SetFCN( function );

	outputParameterList.clear();
	outputParameterList = parameterList;
	std::vector< FitterParameter > tryParamsTemp = parameterList;
	std::vector< FitterParameter > newParamsTemp = parameterList;

	double min = 0.0;
	double *paramDouble = new double[ parameterList.size() ];

	for( int p=0 ; p<parameterList.size() ; p++ )
		paramDouble[p] = parameterList.at( p ).variable;

	int junk = 0;
	function( junk , nullptr , min , paramDouble , 0 );


	for( unsigned int it=0 ; it<numberOfIteration ; it++ ) {

		for( int p=0 ; p<tryParamsTemp.size() ; p++ ) {

			FitterParameter &param = tryParamsTemp.at(p);
			fitter->SetParameter( p , param.name.c_str() , param.variable , param.error , param.lowerValue , param.upperValue );
		}

		// Fitter call
		fitter->ExecuteCommand( minimizerType.c_str() , 0 , 0 );

		// Grab the output from the fitter ...
		for( int p=0 ; p<outputParameterList.size() ; p++ )
			paramDouble[p] = fitter->GetParameter( p );

		double newMin = 0.0;
		function( junk , nullptr , newMin , paramDouble , 0 );

		// ... and compare it with the previous minimization
		if( newMin < min ) {

			min = newMin;

			for( int p=0 ; p<outputParameterList.size() ; p++ )
				outputParameterList.at(p).variable = fitter->GetParameter( p );
		}

		tryParamsTemp = newParamsTemp;
	}

}


bool EnergyMinimizer::Check() {

	if( function == nullptr
	|| numberOfIteration <=0
	|| parameterList.empty()
	|| std::find( availableMinimizerTypes.begin() , availableMinimizerTypes.end() , minimizerType ) == availableMinimizerTypes.end() )
		return false;

	return true;
}

// --------------------------------------------------------------------------------------------------------------------------

EnergyMinimizerProcessor aEnergyMinimizerProcessor;

std::vector< EnergyMinimizerProcessor::MinimizationVariable > EnergyMinimizerProcessor::variables;
std::vector< double > EnergyMinimizerProcessor::energies;

EnergyMinimizerProcessor::EnergyMinimizerProcessor()
	: marlin::Processor("EnergyMinimizerProcessor") {

	  _description = "EnergyMinimizerProcessor :\n"
			  "Compute the parameters needed for energy computation using a minimizer.\n";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  registerProcessorParameter("algorithmConfigFileName" ,
				     "algorithm config file name" ,
				     algorithmConfigFileName,
				     string(""));

	  registerProcessorParameter("rootOutputFile" ,
				     "the ROOT output file for analysis" ,
				     rootOutputFile,
				     string(""));

	  registerProcessorParameter("printOutLevel" ,
				     "the print out level of the minimizer" ,
				     printOutLevel,
				     static_cast<int> (-1) );

	  registerProcessorParameter("minimizerType" ,
				     "the minimizer type. Could be MIGRAD or SIMPLEX" ,
				     minimizerType,
				     string("SIMPLEX"));

	  registerProcessorParameter("nbOfIteration" ,
				     "the number of iterations for the minimizer" ,
				     nbOfIterations,
				     static_cast<int> (3) );

	  registerProcessorParameter("nbOfEnergyParameters" ,
				     "the number of parameters in the energy function" ,
				     nbOfEnergyParameters,
				     static_cast<int> (9) );

	  std::vector<double> eParams( 9 , 0.0 );
	  registerProcessorParameter("energyParameters" ,
				     "the input parameters in the energy function" ,
				     energyParameters,
				     eParams );


	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);

	  inputEnergy = 0.0;
}

EnergyMinimizerProcessor::~EnergyMinimizerProcessor() {}


void EnergyMinimizerProcessor::init() {

	printParameters();

	assert( energyParameters.size() != nbOfEnergyParameters );

	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();
	analysisManager = AnalysisManager::GetInstance();
	minimizer = new EnergyMinimizer();

	analysisManager->SetRootFileName( rootOutputFile );
	analysisManager->Init();

	BaboonMonitoring::SetEnable( false );

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add event preparation algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new EventPreparation() ) );

	// Add clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add tracking algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new TrackFinderAlgorithm() ) );

	// Add isolation algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	algorithmManager->SetConfigFileName( algorithmConfigFileName );

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}

void EnergyMinimizerProcessor::processRunHeader( LCRunHeader* run ) {

}

void EnergyMinimizerProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();
	const LCParameters &params = evt->getParameters();
	double energy = params.getFloatVal("energy");

	// if no calo hit in the collection, no need to process
	if( caloHitCollection->empty() ) {
		this->ClearContent();
		return;
	}

	cout << "event " << evt->getEventNumber() <<  endl;

	// Run the event preparation for calo hit densities
	EventPreparation *eventPreparation = (EventPreparation *) algorithmManager->GetAlgorithm("EventPreparation");
	eventPreparation->Process();


	// Run the isolation algorithm
	IsolationTaggingAlgorithm *isolAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
	isolAlgo->SetCalorimeter( sdhcal );
	isolAlgo->Process();


	// Run 2D clustering algorithm before track finder
	ClusterCollection *clusterCollection2D = new ClusterCollection();
	ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");

	// 2D algo
	clustAlgo->SetClusteringMode( fClustering2D );
	clustAlgo->SetCalorimeter( sdhcal );
	clustAlgo->SetClusterCollection( clusterCollection2D );
	clustAlgo->Process();

	// Register them to the clustering manager
	for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
	}
	// Run the track finder algorithm
	TrackFinderAlgorithm *trackFinder = (TrackFinderAlgorithm *) algorithmManager->GetAlgorithm("TrackFinderAlgorithm");
	trackFinder->SetCalorimeter( sdhcal );
	trackFinder->Process();

	// Run the core finder algorithm
	CoreFinderAlgorithm *coreFinder = ( CoreFinderAlgorithm * ) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
	coreFinder->SetCalorimeter( sdhcal );
	coreFinder->Process();


	this->FillData( energy , caloHitCollection );

	this->ClearContent();
}


void EnergyMinimizerProcessor::check( LCEvent *evt ) {}


void EnergyMinimizerProcessor::end() {

	minimizer->SetPrintOutLevel( printOutLevel );

	// SDHCAL energy formula is:
	// E = ( alpha1 + alpha2*N + alpha3*N*N) *N1
	//   + ( beta1  + beta2*N  + beta3*N*N ) *N2
	//   + ( gamma1 + gamma2*N + gamma3*N*N) *N3

	EnergyMinimizer::FitterParameter alpha1Param;
	alpha1Param.name = "alpha1";
	alpha1Param.variable = energyParameters.at(0);
	alpha1Param.error = 0.00001;
	alpha1Param.lowerValue = 0;
	alpha1Param.upperValue = 0;

	EnergyMinimizer::FitterParameter alpha2Param;
	alpha2Param.name = "alpha2";
	alpha2Param.variable = energyParameters.at(1);
	alpha2Param.error = 0.00001;
	alpha2Param.lowerValue = 0;
	alpha2Param.upperValue = 0;

	EnergyMinimizer::FitterParameter alpha3Param;
	alpha3Param.name = "alpha3";
	alpha3Param.variable = energyParameters.at(2);
	alpha3Param.error = 0.00001;
	alpha3Param.lowerValue = 0;
	alpha3Param.upperValue = 0;

	EnergyMinimizer::FitterParameter beta1Param;
	beta1Param.name = "beta1";
	beta1Param.variable = energyParameters.at(3);
	beta1Param.error = 0.00001;
	beta1Param.lowerValue = 0;
	beta1Param.upperValue = 0;

	EnergyMinimizer::FitterParameter beta2Param;
	beta2Param.name = "beta2";
	beta2Param.variable = energyParameters.at(4);
	beta2Param.error = 0.00001;
	beta2Param.lowerValue = 0;
	beta2Param.upperValue = 0;

	EnergyMinimizer::FitterParameter beta3Param;
	beta3Param.name = "beta3";
	beta3Param.variable = energyParameters.at(5);
	beta3Param.error = 0.00001;
	beta3Param.lowerValue = 0;
	beta3Param.upperValue = 0;

	EnergyMinimizer::FitterParameter gamma1Param;
	gamma1Param.name = "gamma1";
	gamma1Param.variable = energyParameters.at(6);
	gamma1Param.error = 0.00001;
	gamma1Param.lowerValue = 0;
	gamma1Param.upperValue = 0;

	EnergyMinimizer::FitterParameter gamma2Param;
	gamma2Param.name = "gamma2";
	gamma2Param.variable = energyParameters.at(7);
	gamma2Param.error = 0.00001;
	gamma2Param.lowerValue = 0;
	gamma2Param.upperValue = 0;

	EnergyMinimizer::FitterParameter gamma3Param;
	gamma3Param.name = "gamma3";
	gamma3Param.variable = energyParameters.at(8);
	gamma3Param.error = 0.00001;
	gamma3Param.lowerValue = 0;
	gamma3Param.upperValue = 0;

	minimizer->AddParameter( alpha1Param );
	minimizer->AddParameter( alpha2Param );
	minimizer->AddParameter( alpha3Param );
	minimizer->AddParameter( beta1Param  );
	minimizer->AddParameter( beta2Param  );
	minimizer->AddParameter( beta3Param  );
	minimizer->AddParameter( gamma1Param );
	minimizer->AddParameter( gamma2Param );
	minimizer->AddParameter( gamma3Param );

	minimizer->SetMinimizerType( minimizerType );
	minimizer->SetNumberOfIteration( nbOfIterations );
	minimizer->SetFunction( &EnergyMinimizerProcessor::BasicMinuitFunction );

	cout << "Minimizer called" << endl;
	minimizer->Minimize();
	cout << "End of minimization" << endl;

	const std::vector<EnergyMinimizer::FitterParameter> &outputParameters = minimizer->GetOutputParameters();

	for( unsigned int p=0 ; p<outputParameters.size() ; p++ ) {
		cout << "param '" << outputParameters.at(p).name << "' minimized with value " << outputParameters.at(p).variable << endl;
	}

	delete minimizer;

	analysisManager->End();
}


baboon::Return EnergyMinimizerProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			// protecting against sdhcal data with tail catcher
			if( K >= sdhcal->GetNbOfLayers() ) {
				delete caloHit;
				continue;
			}
			// protecting against double hit counting
			if( !sdhcal->IsPadFired( I , J , K ) ) {
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
			}
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}



baboon::Return EnergyMinimizerProcessor::ClearContent() {

	sdhcal->ClearContent();

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();

	return BABOON_SUCCESS();

}


void EnergyMinimizerProcessor::FillData( double energy , CaloHitCollection *caloHitCollection ) {

	energies.push_back( energy );

	int N1 = 0;
	int N2 = 0;
	int N3 = 0;

	for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {

		CaloHit *caloHit = caloHitCollection->at(h);
		if( caloHit->GetThreshold() == fCaloHitThr1 )
			N1++;
		else if( caloHit->GetThreshold() == fCaloHitThr2 )
			N3++;
		else if( caloHit->GetThreshold() == fCaloHitThr3 )
			N2++;

	}

	MinimizationVariable var;
	var.reserve( 4 );
	var.push_back( caloHitCollection->size() );
	var.push_back( N1 );
	var.push_back( N2 );
	var.push_back( N3 );

	variables.push_back( var );

}


void EnergyMinimizerProcessor::BasicMinuitFunction( int& nDim , double* gout , double& result , double par[] , int flg ) {

	double energyReco = 0.0;
	double chi2 = 0.0;

	for( unsigned int v=0 ; v<variables.size() ; v++ ) {

		MinimizationVariable var = variables.at( v );
		energyReco = ( par[ 0 ] + par[ 1 ]*var.at( 0 ) + par[ 2 ]*var.at( 0 )*var.at( 0 ) ) * var.at( 1 )
				   + ( par[ 3 ] + par[ 4 ]*var.at( 0 ) + par[ 5 ]*var.at( 0 )*var.at( 0 ) ) * var.at( 2 )
				   + ( par[ 6 ] + par[ 7 ]*var.at( 0 ) + par[ 8 ]*var.at( 0 )*var.at( 0 ) ) * var.at( 3 );
		chi2 += ( energies.at( v ) - energyReco ) * ( energies.at( v ) - energyReco ) / energies.at( v );

	}

	result = chi2 / (variables.size() + 1);

}


