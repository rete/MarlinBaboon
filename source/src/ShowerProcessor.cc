  /// \file ShowerProcessor.cc
/*
 *
 * ShowerProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */

// class header
#include "ShowerProcessor.hh"

// baboon includes
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"
#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"
#include "Algorithm/EventPreparation.hh"
#include "Geometry/Matrix3D.hh"
#include "Geometry/Cylinder.hh"
#include "Reconstruction/Linear3DFit.hh"
#include "Reconstruction/EnergyCalculator/SimpleEnergyCalculator.hh"


// marlin includes
#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

// root includes
#include <TEveArrow.h>

ShowerProcessor aShowerProcessor;

using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;


ShowerProcessor::ShowerProcessor()
	: marlin::Processor("ShowerProcessor") {

	  _description = "ShowerProcessor to process global variables of a hadronic shower in the SDHCAL detector";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  registerProcessorParameter("algorithmConfigFileName" ,
				     "algorithm config file name" ,
				     algorithmConfigFileName,
				     string(""));

	  registerProcessorParameter("rootOutputFile" ,
				     "the ROOT output file for analysis" ,
				     rootOutputFile,
				     string(""));

	  registerProcessorParameter("enableMonitoring" ,
				     "enable monitoring or not" ,
				     enableMonitoring,
				     false );

	  registerProcessorParameter("displayMode" ,
				     "Display mode" ,
				     displayMode,
				     string("threshold") );

	  registerProcessorParameter("energy" ,
				     "energy" ,
				     energy,
				     0.0 );

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);

	  registerProcessorParameter("slcioOutputFile",
				     "lcio output file",
				     slcioOutputFile,
				     string(""));


}

ShowerProcessor::~ShowerProcessor() {

	delete lcWriter;
}


void ShowerProcessor::init() {

//	monitoring = BaboonMonitoring::GetInstance();
//	detectorManager = DetectorManager::GetInstance();
//	clusteringManager = ClusteringManager::GetInstance();
//	coreManager = CoreManager::GetInstance();
//	showerManager = ShowerManager::GetInstance();
//	trackManager = TrackManager::GetInstance();
//	analysisManager = AnalysisManager::GetInstance();
//
//	analysisManager->SetRootFileName( rootOutputFile );
//	analysisManager->Init();
//
//	BaboonMonitoring::SetEnable( enableMonitoring );
//
//	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {
//
//		sdhcal = new SDHCAL();
//		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );
//
//	}
//	else {
//		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
//	}
//
//	if( displayMode == "thresholds" )
//		sdhcal->SetHitDisplayMode( kDisplayThresholds );
//	else if( displayMode == "showers" )
//		sdhcal->SetHitDisplayMode( kDisplayShowers );
//	else if( displayMode == "tags" )
//		sdhcal->SetHitDisplayMode( kDisplayTags );
//	else if( displayMode == "uniform" )
//		sdhcal->SetHitDisplayMode( kDisplayUniform );
//	else if( displayMode == "custom" )
//		sdhcal->SetHitDisplayMode( kCustom );
//
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );
//
//
//	algorithmManager = AlgorithmManager::GetInstance();
//
//	// Add event preparation algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new EventPreparation() ) );
//
//	// Add clustering algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );
//
//	// Add tracking algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new TrackFinderAlgorithm() ) );
//
//	// Add isolation algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );
//
//	// Add core finder algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );
//
//	algorithmManager->SetConfigFileName( algorithmConfigFileName );
//
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

	lcWriter = IOIMPL::LCFactory::getInstance()->createLCWriter();

	lcWriter->open( slcioOutputFile , LCIO::WRITE_NEW );

}

void ShowerProcessor::processRunHeader( LCRunHeader* run ) {

}

void ShowerProcessor::processEvent( EVENT::LCEvent * evt ) {

//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );
//
//	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();
//
//	unsigned int nbOfLayers = sdhcal->GetNbOfLayers();
//	double cellSize0 = sdhcal->GetCellSize0();
//	double cellSize1 = sdhcal->GetCellSize1();
//	double layerThickness = sdhcal->GetLayerThickness();
//	double absorberThickness = sdhcal->GetAbsorberThickness();
//	int repeatX = sdhcal->GetRepeatX();
//	int repeatY = sdhcal->GetRepeatY();
//
//	double shiftXFactor = cellSize0*repeatX / 2.0;
//	double shiftYFactor = cellSize1*repeatY / 2.0;
//	double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0;
//
//	int nbOfHits = caloHitCollection->size();
//
//	if( caloHitCollection->empty() ) {
//		this->ClearContent();
//		return;
//	}
//
	cout << "event " << evt->getEventNumber() <<  endl;
//
//	if( algorithmManager->AlgorithmIsRegistered("EventPreparation") ) {
//
//		EventPreparation *eventPreparation = (EventPreparation *) algorithmManager->GetAlgorithm("EventPreparation");
////		eventPreparation->SetCalorimeter( sdhcal );
//		eventPreparation->Process();
//	}
//
//	/*********************
//	 * Beginning of computation *
//	 *********************/
//
//	ClusterCollection *clusterCollection2D = new ClusterCollection();
//	ClusterCollection *clusterCollection3D = new ClusterCollection();
//
//	// Clustering analysis
//
//	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {
//
//		IntVector cluster2DSizes;
//		IntVector cluster3DSizes;
//
//		ClusteringAlgorithm *clustAlgo = ( ClusteringAlgorithm * ) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
//
//		// 2D algo
//		clustAlgo->SetClusteringMode( fClustering2D );
//		clustAlgo->SetCalorimeter( sdhcal );
//		clustAlgo->SetClusterCollection( clusterCollection2D );
//		clustAlgo->Process();
//
//		// 3D algo
//		clustAlgo->SetClusteringMode( fClustering3D );
//		clustAlgo->SetCalorimeter( sdhcal );
//		clustAlgo->SetClusterCollection( clusterCollection3D );
//		clustAlgo->Process();
//
//		// Register them to the clustering manager just for memory management...
//		for( unsigned int i=0 ; i<clusterCollection2D->size() ; i++ ) {
//			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection2D->at(i) ) );
//			cluster2DSizes.push_back( clusterCollection2D->at(i)->Size() );
//		}
//
//		for( unsigned int i=0 ; i<clusterCollection3D->size() ; i++ ) {
//			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clusterCollection3D->at(i) ) );
//			cluster3DSizes.push_back( clusterCollection3D->at(i)->Size() );
//		}
//
//		analysisManager->Set( "ClusterAnalysis" , "nbOf2DClusters" , (int)clusterCollection2D->size() );
//		analysisManager->Set( "ClusterAnalysis" , "cluster2DSizes" , &cluster2DSizes );
//		analysisManager->Set( "ClusterAnalysis" , "nbOf3DClusters" , (int)clusterCollection3D->size() );
//		analysisManager->Set( "ClusterAnalysis" , "cluster3DSizes" , &cluster3DSizes );
//		analysisManager->Fill( "ClusterAnalysis" );
//	}
//
//
//
//	// Isolation analysis
//
//	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {
//
//		IsolationTaggingAlgorithm *isolAlgo = ( IsolationTaggingAlgorithm * ) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
//		isolAlgo->SetCalorimeter( sdhcal );
//		isolAlgo->Process();
//
//		int nbOfIsolatedHits = 0;
//		for( auto caloHit : *caloHitCollection )
//			if( caloHit->GetTag() == IsolatedTag() )
//				nbOfIsolatedHits++;
//
//		double isolationDensityThreshold;
//		cfgparser::Data data = isolAlgo->GetData();
//		data.GetValue( "concentrationLimit" , &isolationDensityThreshold );
//
//		analysisManager->Set( "IsolationAnalysis" , "nbOfIsolatedHits" , nbOfIsolatedHits );
//		analysisManager->Set( "IsolationAnalysis" , "isolationDensityThreshold" , isolationDensityThreshold );
//		analysisManager->Set( "IsolationAnalysis" , "isolatedHitFraction" , double( nbOfIsolatedHits ) / double(caloHitCollection->size()) );
//
//
//		SimpleEnergyCalculator energyCalculator;
//		CaloHitCollection nonIsolatedHits;
//
//		for( auto caloHit :*caloHitCollection ) {
//
//			if( caloHit->GetTag() != IsolatedTag() )
//				nonIsolatedHits.push_back( caloHit );
//		}
//
//		energyCalculator.SetCaloHitCollection( &nonIsolatedHits );
//		energyCalculator.CalculateEnergy();
//		double nonIsolatedEnergy = energyCalculator.GetEnergy();
//
//		energyCalculator.SetCaloHitCollection( caloHitCollection );
//		energyCalculator.CalculateEnergy();
//		double energy = energyCalculator.GetEnergy();
//
//		analysisManager->Set( "IsolationAnalysis" , "nonIsolatedEnergy" , nonIsolatedEnergy );
//		analysisManager->Set( "IsolationAnalysis" , "isolatedHitEnergyFraction" , ( energy - nonIsolatedEnergy ) / ( energy ) );
//		analysisManager->Set( "IsolationAnalysis" , "totalEnergy" , energy );
//
//		analysisManager->Fill( "IsolationAnalysis" );
//	}
//
//
//
//	// Core analysis
//
//	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {
//
//		CoreFinderAlgorithm *coreFinder = ( CoreFinderAlgorithm * ) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
//		coreFinder->SetCalorimeter( sdhcal );
//		coreFinder->Process();
//
//		CoreCollection *coreCollection = coreManager->GetCoreCollection();
//		IntVector coreSizes;
//		double buildConcentration = 0.0;
//
//		if( !coreCollection->empty() ) {
//
//			buildConcentration = coreCollection->at( 0 )->GetBuildConcentration();
//
//			for( auto core : *coreCollection )
//				coreSizes.push_back( core->Size() );
//		}
//
//		analysisManager->Set( "CoreAnalysis" , "nbOfCores" , (int)coreCollection->size() );
//		analysisManager->Set( "CoreAnalysis" , "buildConcentration" , buildConcentration );
//		analysisManager->Set( "CoreAnalysis" , "coreSizes" , &coreSizes );
//		analysisManager->Fill( "CoreAnalysis" );
//	}
//
//
//	// Tracking analysis
//
//	if( algorithmManager->AlgorithmIsRegistered("TrackFinderAlgorithm") && !clusterCollection2D->empty() ) {
//
//		TrackFinderAlgorithm *trackFinderAlgo = ( TrackFinderAlgorithm * ) algorithmManager->GetAlgorithm("TrackFinderAlgorithm");
//		trackFinderAlgo->SetCalorimeter( sdhcal );
//		trackFinderAlgo->Process();
//
//
//		TrackCollection *trackCollection = trackManager->GetTrackCollection();
//
//		// Analysis variable registration
//		int nbOfTracks = trackCollection->size();
//		IntVector nbOfHitsForEachTrack;
//		int nbOfTrackHits = 0;
//		DoubleVector trackMultiplicities;
//		DoubleVector trackLengthsMM;
//		IntVector trackLengthsLayer;
//
//		for( unsigned int tr=0 ; tr<trackCollection->size() ; tr++ ) {
//
//			Track *track = trackCollection->at( tr );
//			track->SortHits();
//			nbOfHitsForEachTrack.push_back( track->Size() );
//			IntVector firedPlanes;
//			CaloHitCollection *trackHits = track->GetCaloHitCollection();
//
//			double trackLengthMM = 0;
//			int trackLengthLayer = trackHits->at( trackHits->size() - 1 )->GetIJK().at(2) - trackHits->at(0)->GetIJK().at(2);
//
//			for( unsigned int h=0 ; h<track->Size() ; h++ ) {
//
//				CaloHit *caloHit = trackHits->at( h );
//
//				if( h != track->Size() - 1 ) {
//
//					Cluster *cluster = clusteringManager->GetClusterContainingCaloHit( fCluster2D , caloHit );
//					CaloHit *nextCaloHit = trackHits->at( h+1 );
//					Cluster *nextCluster = clusteringManager->GetClusterContainingCaloHit( fCluster2D , nextCaloHit );
//
//					if( cluster != nextCluster ) {
//
//						ThreeVector clusterPosition = cluster->GetPosition();
//						ThreeVector nextClusterPosition = nextCluster->GetPosition();
//						ThreeVector distanceVector = nextClusterPosition - clusterPosition;
//						distanceVector.setX( distanceVector.x()*cellSize0 );
//						distanceVector.setY( distanceVector.y()*cellSize1 );
//						distanceVector.setZ( distanceVector.z()*layerThickness );
//						trackLengthMM += distanceVector.mag();
//					}
//				}
//
//				if( std::find( firedPlanes.begin() , firedPlanes.end() , caloHit->GetIJK().at(2) ) == firedPlanes.end() )
//					firedPlanes.push_back( caloHit->GetIJK().at(2) );
//
//			}
//			trackLengthsMM.push_back( trackLengthMM );
//			trackLengthsLayer.push_back( trackLengthLayer );
//			nbOfTrackHits += track->Size();
//			trackMultiplicities.push_back( (double)track->Size() / (double)firedPlanes.size() );
//		}
//
//		analysisManager->Set( "TrackAnalysis" , "nbOfTracks" , nbOfTracks );
//		analysisManager->Set( "TrackAnalysis" , "nbOfTrackHits" , nbOfTrackHits );
//		analysisManager->Set( "TrackAnalysis" , "nbOfHitsForEachTrack" , &nbOfHitsForEachTrack );
//		analysisManager->Set( "TrackAnalysis" , "trackMultiplicities" , &trackMultiplicities );
//		analysisManager->Set( "TrackAnalysis" , "trackLengthsMM" , &trackLengthsMM );
//		analysisManager->Set( "TrackAnalysis" , "trackLengthsLayer" , &trackLengthsLayer );
//		analysisManager->Fill( "TrackAnalysis" );
//	}
//
//
//
//	// Calorimeter hit analysis
//
//	for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {
//
//		CaloHit *caloHit = caloHitCollection->at( h );
//
//		analysisManager->Set( "CaloHitAnalysis" , "I" , caloHit->GetIJK().at(0) );
//		analysisManager->Set( "CaloHitAnalysis" , "J" , caloHit->GetIJK().at(1) );
//		analysisManager->Set( "CaloHitAnalysis" , "K" , caloHit->GetIJK().at(2) );
//		analysisManager->Set( "CaloHitAnalysis" , "x" , caloHit->GetPosition().x() );
//		analysisManager->Set( "CaloHitAnalysis" , "y" , caloHit->GetPosition().y() );
//		analysisManager->Set( "CaloHitAnalysis" , "z" , caloHit->GetPosition().z() );
//		analysisManager->Set( "CaloHitAnalysis" , "thr" , static_cast<int> (caloHit->GetThreshold()) );
//		if( caloHit->GetTag() == IsolatedTag() )
//			analysisManager->Set( "CaloHitAnalysis" , "tag" , 1 );
//		else if( caloHit->GetTag() == CoreTag() )
//			analysisManager->Set( "CaloHitAnalysis" , "tag" , 2 );
//		else if( caloHit->GetTag() == TrackTag() )
//			analysisManager->Set( "CaloHitAnalysis" , "tag" , 3 );
//		else if( caloHit->GetTag() == NoiseTag() )
//			analysisManager->Set( "CaloHitAnalysis" , "tag" , 4 );
//		else
//			analysisManager->Set( "CaloHitAnalysis" , "tag" , 0 );
//		analysisManager->Set( "CaloHitAnalysis" , "density" , caloHit->GetDensity() );
//		analysisManager->Fill( "CaloHitAnalysis" );
//
//		// Display if there's one
//		if( caloHit->GetTag() == TrackTag() ) {
//			caloHit->SetColor( kBlack );
//			continue;
//		}
//
//		if( caloHit->GetThreshold() == fCaloHitThr1 )
//			caloHit->SetColor( kGreen );
//		if( caloHit->GetThreshold() == fCaloHitThr2 )
//			caloHit->SetColor( kBlue );
//		if( caloHit->GetThreshold() == fCaloHitThr3 )
//			caloHit->SetColor( kRed );
//
//	}
//
//	bool energyStudy = true;
//
//	if( energyStudy ) {
//
//		SimpleEnergyCalculator calculator;
//
//		CaloHitCollection isolatedHits;
//		CaloHitCollection coreHits;
//		CaloHitCollection trackHits;
//		CaloHitCollection otherHits;
//
//		for( auto caloHit :*caloHitCollection ) {
//			if( caloHit->GetTag() == IsolatedTag() )
//				isolatedHits.push_back( caloHit );
//			else if( caloHit->GetTag() == CoreTag() )
//				coreHits.push_back( caloHit );
//			else if( caloHit->GetTag() == TrackTag() )
//				trackHits.push_back( caloHit );
//			else
//				otherHits.push_back( caloHit );
//		}
//
//		calculator.SetCaloHitCollection( &isolatedHits );
//		calculator.CalculateEnergy();
//		double isolatedEnergy = calculator.GetEnergy();
//		analysisManager->Set( "EnergyAnalysis" , "isolated" , isolatedEnergy );
//
//		calculator.SetCaloHitCollection( &coreHits );
//		calculator.CalculateEnergy();
//		double coreEnergy = calculator.GetEnergy();
//		analysisManager->Set( "EnergyAnalysis" , "core" , coreEnergy );
//
//		calculator.SetCaloHitCollection( &trackHits );
//		calculator.CalculateEnergy();
//		double trackEnergy = calculator.GetEnergy();
//		analysisManager->Set( "EnergyAnalysis" , "track" , trackEnergy );
//
//		calculator.SetCaloHitCollection( &otherHits );
//		calculator.CalculateEnergy();
//		double otherEnergy = calculator.GetEnergy();
//		analysisManager->Set( "EnergyAnalysis" , "other" , otherEnergy );
//
//		double energySum = isolatedEnergy + coreEnergy + trackEnergy + otherEnergy;
//		analysisManager->Set( "EnergyAnalysis" , "energySum" , energySum );
//
//		calculator.SetCaloHitCollection( caloHitCollection );
//		calculator.CalculateEnergy();
//		double totalEnergy = calculator.GetEnergy();
//		analysisManager->Set( "EnergyAnalysis" , "total" , totalEnergy );
//
//		analysisManager->Set( "EnergyAnalysis" , "sumTotalFraction" , ( totalEnergy - energySum ) / totalEnergy );
//
//		analysisManager->Fill( "EnergyAnalysis" );
//
//	}
//
//
//	// Single particle (SP) study for PFA improvement.
//	// Studies the energy probability function ( gauss rep func ) on SP reco
//
//	bool singleParticleStudy = false;
//
//	do {
//
//		if( !singleParticleStudy )
//			break;
//
//		// Choose first an event where a primary track has been found
//		TrackCollection *trackCollection = trackManager->GetTrackCollection();
//		Track *primaryTrack = nullptr;
//
//		for( auto track :*trackCollection ) {
//
//			TrackExtremities extremities = track->GetExtremities();
//			CaloHit *first = extremities.first;
//			CaloHit *last = extremities.second;
//
//			ThreeVector direction = first->GetPosition() - last->GetPosition();
//			if( direction.z() < 0.f )
//				direction = -direction;
//
//			if( direction.theta() < 0.3 ) {
//				if( first->GetPosition().z() < -600.f || last->GetPosition().z() < -600.f ) {
//					primaryTrack = track;
//				}
//			}
//		}
//
//		if( primaryTrack == nullptr )
//			break;
//		cout << "A primary track has been found" << endl;
//
//
//
//
//
//		// Fake do while
//		break;
//	} while(1);
//
//
//	// View event if the monitoring is available
//	monitoring->ViewEvent();
//
//
//	this->ClearContent();

	evt->parameters().setValue( "energy" , float(energy) );
	lcWriter->writeEvent( evt );
}





void ShowerProcessor::check( LCEvent *evt ) {

}

void ShowerProcessor::end() {

	lcWriter->close();
//	analysisManager->End();
}


baboon::Return ShowerProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			// protecting against sdhcal data with tail catcher
			if( K >= sdhcal->GetNbOfLayers() ) {
				delete caloHit;
				continue;
			}
			// protecting against double hit counting
			if( !sdhcal->IsPadFired( I , J , K ) ) {
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
			}
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}



baboon::Return ShowerProcessor::ClearContent() {

	sdhcal->ClearContent();

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();

	return BABOON_SUCCESS();

}



