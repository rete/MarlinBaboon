  /// \file TestBeamCutsProcessor.cc
/*
 *
 * TestBeamCutsProcessor.cc source template generated by fclass
 * Creation date : lun. mai 27 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "TestBeamCutsProcessor.hh"

#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"

#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

using namespace std;
using namespace baboon;
using namespace EVENT;

TestBeamCutsProcessor aTestBeamCutsProcessor;

TestBeamCutsProcessor::TestBeamCutsProcessor()
	: marlin::Processor("TestBeamCutsProcessor") {

	  _description = "TestBeamCutsProcessor to apply some basic cuts after test beams. Cut electrons and muons, keep only pions";

	  registerProcessorParameter("electronConcentrationCut",
				     "cut on concentration coreHits/isolatedHits",
				     electronConcentrationCut,
				     0.0);

	  registerProcessorParameter("muonConcentrationCut",
				     "cut on concentration isolatedHits/total",
				     muonConcentrationCut,
				     0.0);

	  registerProcessorParameter("muonMultiplicityCut",
				     "cut on muon multiplicity ",
				     muonMultiplicityCut,
				     0.0);

	  registerProcessorParameter("totalNbOfHitsCut",
				     "cut on concentration total number of hits",
				     totalNbOfHitsCut,
				     100000);

	  registerProcessorParameter("slcioOutputFile",
				     "lcio output file",
				     slcioOutputFile,
				     string(""));

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);


	  lcWriter = IOIMPL::LCFactory::getInstance()->createLCWriter();

}

TestBeamCutsProcessor::~TestBeamCutsProcessor() {

	delete lcWriter;
}



void TestBeamCutsProcessor::init() {

	monitoring = BaboonMonitoring::GetInstance();

	BaboonMonitoring::SetEnable( true );

	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add the Hough Transform Algorithm for track reconstruction within the sdhcal
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new HoughTransformAlgorithm() ) );

	// Add clustering algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	lcWriter->open( slcioOutputFile , LCIO::WRITE_NEW );

	algorithmManager->SetConfigFileName("/home/remi/ilcsoft/SDHCAL/Baboon/config/Algorithm.cfg");

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}


void TestBeamCutsProcessor::processRunHeader( LCRunHeader* run ) {

}


void TestBeamCutsProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	unsigned int evtNb = evt->getEventNumber();
	cout << "event " << evtNb <<  endl;
	nbOfProcessedEvent++;

	if( caloHitCollection->size() < totalNbOfHitsCut ) {
		nbOfCutOnHits++;
		return;
	}

	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		cout << "IsolationTaggingAlgorithm found" << endl;
		IsolationTaggingAlgorithm* isolationAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , isolationAlgo->SetCalorimeter( sdhcal ) );
		isolationAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		cout << "CoreFinderAlgorithm found" << endl;
		CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm*) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , coreFinder->SetCalorimeter( sdhcal ) );
		coreFinder->Process();
	}

	double coreHits = 0;
	double isolatedHits = 0;

	vector<int> touchedLayers;

	for(unsigned int i=0 ; i<caloHitCollection->size() ; i++) {

		if( caloHitCollection->at(i)->GetTag() == CoreTag::Tag() )
			coreHits++;
		else if( caloHitCollection->at(i)->GetTag() == IsolatedTag::Tag() )
			isolatedHits++;
		int layer = caloHitCollection->at(i)->GetIJK().at(2);
		if( std::find( touchedLayers.begin() , touchedLayers.end() , layer ) == touchedLayers.end() )
			touchedLayers.push_back( layer );
	}

	if( isolatedHits == 0 )
		isolatedHits++;

	cout << "core percent : " << coreHits/caloHitCollection->size() << endl;
	cout << "isolated percent : " << isolatedHits/caloHitCollection->size() << endl;
	cout << "coreHits/isolatedHits : " << coreHits/isolatedHits << endl;


	// cut on muon if
	if( isolatedHits/caloHitCollection->size() > muonConcentrationCut ) {
		nbOfCutOnMuon++;
		return;
	}

	// another cut on muon if
	if( caloHitCollection->size()/touchedLayers.size() < muonMultiplicityCut ) {
		nbOfCutOnMuon++;
		return;
	}

	// cut on electron if
	if( coreHits/isolatedHits > electronConcentrationCut ) {
		nbOfCutOnElectron++;
		return;
	}

	// write the final event in an other file.
	lcWriter->writeEvent( evt );
}


void TestBeamCutsProcessor::check( LCEvent *evt ) {

}

void TestBeamCutsProcessor::end() {

	lcWriter->close();
	cout << "nbOfCutOnHits     : " << nbOfCutOnHits << "/" << nbOfProcessedEvent << endl;
	cout << "nbOfCutOnElectron : " << nbOfCutOnElectron << "/" << nbOfProcessedEvent << endl;
	cout << "nbOfCutOnMuon     : " << nbOfCutOnMuon << "/" << nbOfProcessedEvent << endl;
}



baboon::Return TestBeamCutsProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}


