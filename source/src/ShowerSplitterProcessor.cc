  /// \file ShowerSplitterProcessor.cc
/*
 *
 * ShowerSplitterProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */

// class header
#include "ShowerSplitterProcessor.hh"

#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"
#include "Algorithm/Calorimetry/WeightNormalizationAlgorithm.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"

// baboon includes
#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"
#include "Algorithm/Calorimetry/WeightNormalizationAlgorithm.hh"
#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"
#include "Algorithm/Calorimetry/CoreFinderAlgorithm.hh"
#include "Algorithm/Calorimetry/HoughTransformAlgorithm.hh"
#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"
#include "Algorithm/PCA.hh"
#include "Reconstruction/EnergyCalculator/WeightEnergyCalculator.hh"
#include "Reconstruction/EnergyCalculator/SimpleEnergyCalculator.hh"
#include "Utilities/Internal.hh"
#include "Utilities/ReturnValues.hh"
#include "Utilities/Globals.hh"
#include "Utilities/CaloHitHelper.hh"

#include "marlin/Global.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

ShowerSplitterProcessor aShowerSplitterProcessor;


using namespace std;
using namespace baboon;
using namespace cfgparser;
using namespace EVENT;
using namespace marlin;


ShowerSplitterProcessor::ShowerSplitterProcessor()
	: marlin::Processor("ShowerSplitterProcessor") {

	  _description = "ShowerSplitterProcessor for shower splitting in SDHCAL";

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("SDHCALCollectionName" ,
				     "collection name for SDHCAL hits" ,
				     SDHCALCollectionName,
				     string("HCALBarrel"));

	  vector<string> ijkVec;
	  ijkVec.push_back("I");
	  ijkVec.push_back("J");
	  ijkVec.push_back("K-1");

	  registerProcessorParameter("IJKEncoding",
				     "I J K hit encoding",
				     IJKEncoding,
				     ijkVec);


}

ShowerSplitterProcessor::~ShowerSplitterProcessor() {}


void ShowerSplitterProcessor::init() {

	monitoring = BaboonMonitoring::GetInstance();
	detectorManager = DetectorManager::GetInstance();
	clusteringManager = ClusteringManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	showerManager = ShowerManager::GetInstance();
	trackManager = TrackManager::GetInstance();

	if( !detectorManager->DetectorIsRegistered("SDHCAL") ) {

		sdhcal = new SDHCAL();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->RegisterDetector( sdhcal ) );

	}
	else {
		sdhcal = (SDHCAL *) detectorManager->GetDetector("SDHCAL");
	}

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , detectorManager->Init( marlin::Global::GEAR ) );


	algorithmManager = AlgorithmManager::GetInstance();

	// Add the Hough Transform Algorithm for track reconstruction within the sdhcal
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new HoughTransformAlgorithm() ) );

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	// Add clustering (2D) algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	// Add shower agglomeration algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ShowerAgglomerationAlgorithm() ) );

	// weight normalization algorithm for shower weights
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new WeightNormalizationAlgorithm() ) );

	algorithmManager->SetConfigFileName("/home/remi/ilcsoft/SDHCAL/Baboon/config/Algorithm.cfg");

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->Initialize() );

}

void ShowerSplitterProcessor::processRunHeader( LCRunHeader* run ) {

}

void ShowerSplitterProcessor::processEvent( EVENT::LCEvent * evt ) {

	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->LoadSDHCALHits( sdhcal , evt ) );

	CaloHitCollection *caloHitCollection = sdhcal->GetCaloHitCollection();

	int nbOfHits = caloHitCollection->size();

	if( caloHitCollection->empty() )
		return;

	unsigned int evtNb = evt->getEventNumber();
	cout << "event " << evtNb <<  endl;

	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm* isolationAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , isolationAlgo->SetCalorimeter( sdhcal ) );
		isolationAlgo->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm *) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , coreFinder->SetCalorimeter( sdhcal ) );
		coreFinder->Process();
	}



	IntVector coreSizes;
	int nbOfCores = 0;
	Core *mainCore = 0;
	double firstBarycenterZ = 100000;
	CoreCollection *coreCollection = coreManager->GetCoreCollection();
	nbOfCores = coreCollection->size();
	int mainCoreSize = 0;

	for( unsigned int i=0 ; i<coreCollection->size() ; i++ ) {
		coreSizes.push_back( coreCollection->at(i)->Size() );
		double barycenterZ = 0;
		ThreeVector barycenter;
		CaloHitCollection *coreHits = coreCollection->at(i)->GetCaloHitCollection();
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , CaloHitHelper::ComputeBarycenter( coreHits , barycenter ) );
		barycenterZ = barycenter.z();

		if( barycenterZ<firstBarycenterZ ) {
			firstBarycenterZ = barycenterZ;
			mainCore = coreCollection->at(i);
		}
	}
	if( mainCore != 0 )
		mainCoreSize = mainCore->Size();


	analysisManager->Set("CoreAnalysis","nbOfCores",nbOfCores);
	analysisManager->Set("CoreAnalysis","mainCoreSize",mainCoreSize);
	analysisManager->Set("CoreAnalysis","coreSizes",&coreSizes);
	analysisManager->Set("CoreAnalysis","nbOfHits",nbOfHits);
//
//	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {
//
////		cout << "ClusteringAlgorithm found" << endl;
//		ClusterCollection *clustCol = new ClusterCollection();
//		ClusteringAlgorithm* clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
//		clusteringAlgo->SetClusteringMode( fClustering2D );
//		clusteringAlgo->SetTaggingMode( fClusterTagMode );
////		clusteringAlgo->AddHitTagToCluster( fIsolated );
//		clusteringAlgo->SetClusterCollection( clustCol );
//		clusteringAlgo->Process();
//
//		for( unsigned int i=0 ; i<clustCol->size() ; i++ )
//			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clustCol->at(i) ) );
//
//		clustCol->clear();
//		delete clustCol;
//	}
//
	vector<int> clusterSizes;
	ClusterCollection *clusterCollection = clusteringManager->GetCluster2D();
//
//	for( unsigned int i=0 ; i<clusterCollection->size() ; i++ ) {
//		clusterSizes.push_back( clusterCollection->at(i)->Size() );
//	}


//	if( algorithmManager->AlgorithmIsRegistered("HoughTransformAlgorithm") ) {
//
//		cout << "HoughTransformAlgorithm found" << endl;
//		HoughTransformAlgorithm *houghAlgo = (HoughTransformAlgorithm *) algorithmManager->GetAlgorithm("HoughTransformAlgorithm");
//		houghAlgo->Process();
//	}


	analysisManager->Set("ClusteringAnalysis","nbOfClusters",int(clusterCollection->size()));
	analysisManager->Set("ClusteringAnalysis","clusterSizes",&clusterSizes);
	analysisManager->Set("ClusteringAnalysis","nbOfHits",nbOfHits);

/*
	coreManager->ClearAllContent();

	vector<double> coreSizeLoss;

	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm")
	 && algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		int coreSizeStep1 = 0;
		int coreSizeStep2 = 0;

		CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm *) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		ClusteringAlgorithm *clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");

		for( double c=0.3 ; c<=1.6 ; c+=0.1  ) {

			Data algoConfig = coreFinder->GetData();
			ostringstream ss;
			ss << c;
			algoConfig.Append("minimumThresholdConcentration",ss.str());

			coreFinder->SetData( algoConfig );
			coreFinder->Process();

			ClusterCollection *clustCol = new ClusterCollection();

			clusteringAlgo->SetClusteringMode( fClustering3D );
			clusteringAlgo->SetTaggingMode( fClusterTagMode );
			clusteringAlgo->AddHitTagToCluster( fCore );
			clusteringAlgo->SetClusterCollection( clustCol );
			clusteringAlgo->Process();

			for( unsigned int i=0 ; i<clustCol->size() ; i++ ) {

				HitCollection *hitCol = clustCol->at(i)->GetHitCollection();
				Core *core = new Core();
				for( unsigned int j=0 ; j<hitCol->size() ; j++ ) {
					core->AddHit( hitCol->at(j) );
				}
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , coreManager->AddCore( core ) );
			}
			clustCol->clear();
			delete clustCol;

			IntVector coreSizes;
			int nbOfCores = 0;
			Core *mainCore = 0;
			double firstBarycenterZ = 100000;
			CoreCollection *coreCollection = coreManager->GetCoreCollection();
			nbOfCores = coreCollection->size();
			int mainCoreSize = 0;

			for( unsigned int i=0 ; i<coreCollection->size() ; i++ ) {
				coreSizes.push_back( coreCollection->at(i)->Size() );
				double barycenterZ = coreCollection->at(i)->GetHitCollection()->GetBarycenter().z();

				if( barycenterZ<firstBarycenterZ ) {
					firstBarycenterZ = barycenterZ;
					mainCore = coreCollection->at(i);
				}
			}
			if( mainCore !=0 )
				mainCoreSize = mainCore->Size();

			if( c != 0.3 ) {

				coreSizeStep1 = coreSizeStep2;
				coreSizeStep2 = mainCoreSize;
				coreSizeLoss.push_back( double(coreSizeStep1 - coreSizeStep2) / coreSizeStep1 );
			}
			else {
				coreSizeStep1 = mainCoreSize;
			}
		}
	}

	analysisManager->Set("CoreAnalysis","coreSizeLoss",&coreSizeLoss);
*/
//	if( algorithmManager->AlgorithmIsRegistered("ShowerAgglomerationAlgorithm") ) {
//
//		ShowerAgglomerationAlgorithm *showerAggloAlgo = (ShowerAgglomerationAlgorithm *) algorithmManager->GetAlgorithm("ShowerAgglomerationAlgorithm");
//		showerAggloAlgo->Process();
//	}
//
//	if( algorithmManager->AlgorithmIsRegistered("WeightNormalizationAlgorithm") ) {
//
//		WeightNormalizationAlgorithm *showerNormAlgo = (WeightNormalizationAlgorithm *) algorithmManager->GetAlgorithm("WeightNormalizationAlgorithm");
//		showerNormAlgo->Process();
//	}

//	ShowerCollection *showerCollection = showerManager->GetShowerCollection();
//
//	for( unsigned int s=0 ; s<showerCollection->size() ; s++ ) {
//
//		CaloHitCollection *showerHits = showerCollection->at(s)->GetCaloHitCollection();
//		for( unsigned int h=0 ; h<showerHits->size() ; h++ ) {
//			IntVector ijk = showerHits->at(h)->GetIJK();
//			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(s+3);
//		}
//	}

/*
	for(unsigned int j=0 ; j<hitCollection->size() ; j++) {

		IntVector ijk = hitCollection->at(j)->GetIJK();

/*
		if( hitCollection->at(j)->GetThreshold() == fThreshold1 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGreen);
		}

		if( hitCollection->at(j)->GetThreshold() == fThreshold2 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kBlue);
		}

		if( hitCollection->at(j)->GetThreshold() == fThreshold3 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kRed);
		}


		if( hitCollection->at(j)->GetHitTag() == fTrack ) {
//			ITrack.push_back( ijk.at(0) );
//			JTrack.push_back( ijk.at(1) );
//			KTrack.push_back( ijk.at(2) );
			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kRed);
		}
		else if (hitCollection->at(j)->GetHitTag() == fTrackExtremity) {
//			ITrackExtr.push_back( ijk.at(0) );
//			JTrackExtr.push_back( ijk.at(1) );
//			KTrackExtr.push_back( ijk.at(2) );
			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
			calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGreen);
		}
		else if( hitCollection->at(j)->GetHitTag() == fCore ) {
//			ICore.push_back( ijk.at(0) );
//			JCore.push_back( ijk.at(1) );
//			KCore.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGray+3);
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kMagenta);
			continue;
		}
		else if( hitCollection->at(j)->GetHitTag() == fIsolated ) {
//			IIsolated.push_back( ijk.at(0) );
//			JIsolated.push_back( ijk.at(1) );
//			KIsolated.push_back( ijk.at(2) );
			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(2);
		}
		else {
//			I.push_back( ijk.at(0) );
//			J.push_back( ijk.at(1) );
//			K.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGray+3);
		}
	}

//*/
	analysisManager->Fill("ClusteringAnalysis");
	analysisManager->Fill("CoreAnalysis");

	clusteringManager->ClearAllContent();
	coreManager->ClearAllContent();
	showerManager->ClearAllContent();
	trackManager->ClearAllContent();
}


void ShowerSplitterProcessor::check( LCEvent *evt ) {

}

void ShowerSplitterProcessor::end() {

}


baboon::Return ShowerSplitterProcessor::LoadSDHCALHits( SDHCAL *sdhcal , EVENT::LCEvent *evt ) {

	try {

		LCCollection *collection = evt->getCollection( SDHCALCollectionName );
		UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding( decoderString );
		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( collection );

		for( unsigned int i=0 ; i<collection->getNumberOfElements() ; i++ ) {

			if( collection->getTypeName() != LCIO::CALORIMETERHIT )
				return  BABOON_INVALID_PARAMETER("Collection name must be a CalorimeterHit collection");

			CalorimeterHit *hit = static_cast<CalorimeterHit*> ( collection->getElementAt(i) );

			CaloHit *caloHit = new CaloHit( fSemiDigitalCaloHit );
			if( hit->getEnergy() == 1.0 ) caloHit->SetThreshold( fCaloHitThr1 );
			else if( hit->getEnergy() == 2.0 ) caloHit->SetThreshold( fCaloHitThr2 );
			else if( hit->getEnergy() == 3.0 ) caloHit->SetThreshold( fCaloHitThr3 );
			else
				return BABOON_INVALID_PARAMETER("Energy of SDHCAL hit is not in threshold unit (1,2,3)");

			ThreeVector position;
			position.setX( hit->getPosition()[0] );
			position.setY( hit->getPosition()[1] );
			position.setZ( hit->getPosition()[2] );
			caloHit->SetPosition( position );
			int I = cellIdDecoder(hit)[IJKEncoding.at(0).c_str()];
			int J = cellIdDecoder(hit)[IJKEncoding.at(1).c_str()];
			int K = cellIdDecoder(hit)[IJKEncoding.at(2).c_str()];
			caloHit->SetIJK( I , J , K );
			caloHit->SetTypeID( hit->getType() );
			caloHit->SetTime( hit->getTime() );

			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , sdhcal->AddCaloHit( caloHit ) );
		}
	}
	catch ( DataNotAvailableException &e ) {

		return BABOON_ERROR( "LCIO exception thrown : " + string(e.what()) );
	}
	catch ( baboon::Exception &e ) {

		return BABOON_ERROR( "Failed to create hit. " + string(e.what()) );
	}

	return BABOON_SUCCESS();

}
